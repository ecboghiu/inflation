<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>causalinflation.quantum package &mdash; inflation 0.1 documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "tex2jax_ignore|mathjax_ignore|document", "processClass": "tex2jax_process|mathjax_process|math|output_area"}})</script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="causalinflation package" href="causalinflation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> inflation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="download.html">Download and Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples and features</a></li>
<li class="toctree-l1"><a class="reference internal" href="contribute.html">How to contribute</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">causalinflation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="causalinflation.html">causalinflation package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="causalinflation.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">causalinflation.quantum package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="causalinflation.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="causalinflation.html#module-causalinflation.InflationProblem">causalinflation.InflationProblem module</a></li>
<li class="toctree-l3"><a class="reference internal" href="causalinflation.html#module-causalinflation.useful_distributions">causalinflation.useful_distributions module</a></li>
<li class="toctree-l3"><a class="reference internal" href="causalinflation.html#module-causalinflation">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">inflation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="modules.html">causalinflation</a> &raquo;</li>
          <li><a href="causalinflation.html">causalinflation package</a> &raquo;</li>
      <li>causalinflation.quantum package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/causalinflation.quantum.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="causalinflation-quantum-package">
<h1>causalinflation.quantum package<a class="headerlink" href="#causalinflation-quantum-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-causalinflation.quantum.InflationSDP">
<span id="causalinflation-quantum-inflationsdp-module"></span><h2>causalinflation.quantum.InflationSDP module<a class="headerlink" href="#module-causalinflation.quantum.InflationSDP" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="causalinflation.quantum.InflationSDP.InflationSDP">
<em class="property">class </em><code class="sig-prename descclassname">causalinflation.quantum.InflationSDP.</code><code class="sig-name descname">InflationSDP</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">InflationProblem</span><span class="p">:</span> <span class="n"><a class="reference internal" href="causalinflation.html#causalinflation.InflationProblem.InflationProblem" title="causalinflation.InflationProblem.InflationProblem">causalinflation.InflationProblem.InflationProblem</a></span></em>, <em class="sig-param"><span class="n">commuting</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/causalinflation/quantum/InflationSDP.html#InflationSDP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.InflationSDP.InflationSDP" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class for generating and solving an SDP relaxation for quantum inflation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>InflationProblem</strong> (<a class="reference internal" href="causalinflation.html#causalinflation.InflationProblem" title="causalinflation.InflationProblem"><em>InflationProblem</em></a>) – Details of the scenario.</p></li>
<li><p><strong>commuting</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether variables in the problem are going to be commuting
(classical problem) or non-commuting (quantum problem),
by default False.</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em>) – <dl class="simple">
<dt>Optional parameter for level of verbose:</dt><dd><ul>
<li><p>0: quiet (default),</p></li>
<li><p>1: verbose,</p></li>
<li><p>2: debug level,</p></li>
</ul>
</dd>
</dl>
<p>by default 0.</p>
</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="causalinflation.quantum.InflationSDP.InflationSDP.build_columns">
<code class="sig-name descname">build_columns</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">column_specification</span></em>, <em class="sig-param"><span class="n">max_monomial_length</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">0</span></em>, <em class="sig-param"><span class="n">return_columns_numerical</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/causalinflation/quantum/InflationSDP.html#InflationSDP.build_columns"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.InflationSDP.InflationSDP.build_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the input for the columns of the SDP relaxation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>column_specification</strong> (<em>Union</em><em>[</em><em>str</em><em>, </em><em>List</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em><em>,</em>) – List[sympy.core.symbol.Symbol]]
See description in the self.generate_relaxation()` method.</p></li>
<li><p><strong>max_monomial_length</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of letters in a monomial in the generating set,
by default 0 (no limit). Example: if we choose ‘local1’ for 3
parties, this gives the set {1, A, B, C, A*B, A*C, B*C, A*B*C}.
If we set max_monomial_length=2, we remove all terms with more
than 2 letters, and the generating set becomes:
{1, A, B, C, A*B, A*C, B*C}.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="causalinflation.quantum.InflationSDP.InflationSDP.certificate_as_correlators">
<code class="sig-name descname">certificate_as_correlators</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">clean</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">chop_tol</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1e-10</span></em>, <em class="sig-param"><span class="n">round_decimals</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">3</span></em><span class="sig-paren">)</span> &#x2192; sympy.core.symbol.Symbol<a class="reference internal" href="_modules/causalinflation/quantum/InflationSDP.html#InflationSDP.certificate_as_correlators"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.InflationSDP.InflationSDP.certificate_as_correlators" title="Permalink to this definition">¶</a></dt>
<dd><p>Give certificate as symbolic sum of 2-output correlators that
is greater than or equal to 0. Only valid for 2-output problems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clean</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, eliminate all coefficients that are smaller
than ‘chop_tol’, normalise and round to the number of decimals
specified <cite>round_decimals</cite>. Defaults to True.</p></li>
<li><p><strong>chop_tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Coefficients in the dual certificate smaller in absolute value are
set to zero. Defaults to 1e-8.</p></li>
<li><p><strong>round_decimals</strong> (<em>int</em><em>, </em><em>optional</em>) – Coefficients that are not set to zero are rounded to the number
of decimals specified. Defaults to 3.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The certificate in terms of correlators.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sympy.core.symbol.Symbol</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="causalinflation.quantum.InflationSDP.InflationSDP.certificate_as_objective">
<code class="sig-name descname">certificate_as_objective</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">clean</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">chop_tol</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1e-10</span></em>, <em class="sig-param"><span class="n">round_decimals</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">3</span></em><span class="sig-paren">)</span> &#x2192; sympy.core.symbol.Symbol<a class="reference internal" href="_modules/causalinflation/quantum/InflationSDP.html#InflationSDP.certificate_as_objective"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.InflationSDP.InflationSDP.certificate_as_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>Give certificate as symbolic sum of operators that can be used
as an objective function to optimse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clean</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, eliminate all coefficients that are smaller
than ‘chop_tol’, normalise and round to the number of decimals
specified <cite>round_decimals</cite>. Defaults to True.</p></li>
<li><p><strong>chop_tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Coefficients in the dual certificate smaller in absolute value are
set to zero. Defaults to 1e-8.</p></li>
<li><p><strong>round_decimals</strong> (<em>int</em><em>, </em><em>optional</em>) – Coefficients that are not set to zero are rounded to the number
of decimals specified. Defaults to 3.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The certificate as an objective function.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sympy.core.symbol.Symbol</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="causalinflation.quantum.InflationSDP.InflationSDP.certificate_as_probs">
<code class="sig-name descname">certificate_as_probs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">clean</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">chop_tol</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1e-10</span></em>, <em class="sig-param"><span class="n">round_decimals</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">3</span></em><span class="sig-paren">)</span> &#x2192; sympy.core.symbol.Symbol<a class="reference internal" href="_modules/causalinflation/quantum/InflationSDP.html#InflationSDP.certificate_as_probs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.InflationSDP.InflationSDP.certificate_as_probs" title="Permalink to this definition">¶</a></dt>
<dd><p>Give certificate as symbolic sum of probabilities that is greater
than or equal to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clean</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, eliminate all coefficients that are smaller
than ‘chop_tol’ and round to the number of decimals specified
<cite>round_decimals</cite>. Defaults to True.</p></li>
<li><p><strong>chop_tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Coefficients in the dual certificate smaller in absolute value are
set to zero. Defaults to 1e-8.</p></li>
<li><p><strong>round_decimals</strong> (<em>int</em><em>, </em><em>optional</em>) – Coefficients that are not set to zero are rounded to the number
of decimals specified. Defaults to 3.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The certificate in terms or probabilities and marginals.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sympy.core.symbol.Symbol</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="causalinflation.quantum.InflationSDP.InflationSDP.dump_to_file">
<code class="sig-name descname">dump_to_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/causalinflation/quantum/InflationSDP.html#InflationSDP.dump_to_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.InflationSDP.InflationSDP.dump_to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the whole object to a file using <cite>pickle</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str</em>) – Name of the file.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="causalinflation.quantum.InflationSDP.InflationSDP.generate_relaxation">
<code class="sig-name descname">generate_relaxation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">column_specification</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>str<span class="p">, </span>List<span class="p">[</span>List<span class="p">[</span>int<span class="p">]</span><span class="p">]</span><span class="p">, </span>List<span class="p">[</span>sympy.core.symbol.Symbol<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">'npa1'</span></em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/causalinflation/quantum/InflationSDP.html#InflationSDP.generate_relaxation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.InflationSDP.InflationSDP.generate_relaxation" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Creates the SDP relaxation of the quantum inflation problem</dt><dd><p>using the NPA hierarchy and applies the symmetries inferred
from inflation.</p>
<p>It takes as input the generating set of monomials {M_i}_i. The moment
matrix Gamma is defined by all the possible inner products between these
monomials:</p>
<div class="math notranslate nohighlight">
\[\Gamma[i, j] := \operatorname{tr} (\]</div>
</dd>
</dl>
<p>ho * (M_i)^dagger M_j).</p>
<blockquote>
<div><p>The set {M_i} is specified by the parameter <cite>column_specification</cite>.</p>
<p>In the inflated graph there are many symmetries coming from invariance
under swaps of the copied sources, which are used to remove variables
in the moment matrix.</p>
<p>Parameters</p>
<dl>
<dt>column_specification<span class="classifier">Union[str, List[List[int]], List[sympy.core.symbol.Symbol]]</span></dt><dd><p>Describes the generating set of monomials {M_i}_i.</p>
<p>(NOTATION) If we have 2 parties, we denote by {A, B} the set
of all measurement operators of these two parties. That is, {A, B}
represents {A_{InflIndices1}_x_a, B_{InflIndices2}_y_b} for all
possible indices {InflIndices1, InflIndices2, x, a, y, b}.
Similarly, the product {A*B} represents the product of the
operators of A and B for all possible indices. Note that with this
notation, A*A and A**2 represent different sets.</p>
<ul class="simple">
<li><p><cite>(str) ‘npaN’</cite>: where N is an integer. This represents NPA level N.</p></li>
</ul>
<p>This is built by taking the cartesian product of the flattened
set of measurement operators N times and removing duplicated
elements. For example, level 3 with measurements {A, B} will give
the set {1, A, B, A*A, A*B, B*B, A*A*A, A*A*B, A*B*C, A*B*B,
B*B*B}. This is known to converge to the quantum set Q for
N-&gt;infty.</p>
<ul class="simple">
<li><p><cite>(str) ‘localN’</cite>: where N is an integer. This gives a subset of NPA level N+1.</p></li>
</ul>
<p>Local level N considers monomials that have at most
N measurement operators per party. For example, <cite>local1</cite> is a
subset of <cite>npa2</cite>; for 2 parties, <cite>npa2</cite> is {1, A, B, A*A, A*B, B*B}
while <cite>local1</cite> is {1, A, B, A*B}. Note that terms such as
A*A are missing as that is more than N=1 measurements per party.</p>
<ul class="simple">
<li><p><cite>(str) ‘physicalN’</cite>: The subset of local level N with only all commuting operators.</p></li>
</ul>
<p>We only consider commutation coming from having different supports.
<cite>N</cite> cannot be greater than the smallest number of copies of a source
in the inflated graph. For example, in the bilocal scenario
A-source-B-source-C with 2 outputs and no inputs, <cite>physical2</cite> only
gives 5 possibilities for Bob: {1, B_1_1_0_0, B_2_2_0_0,
B_1_1_0_0*B_2_2_0_0,  B_1_2_0_0*B_2_1_0_0}. There are no other
products where all operators commute. The full set of physical
generating monomials is built by taking the cartesian product
between all possible physical monomials of each party.</p>
<ul class="simple">
<li><p><cite>List[List[int]]</cite>: This encodes a party block structure.</p></li>
</ul>
<p>Each integer encodes a party. Within a party block, all missing
input, output and inflation  indices are taken into account.
For example, [[], [0], [1], [0, 1]] gives the set {1, A, B, A*B},
which is the same as ‘local1’. The set [[], [0], [1], [2], [0, 0],
[0, 1], [0, 2], [1, 1], [1, 2], [2, 2]] is the same as {1, A, B,
C, A*A, A*B, A*C, B*B, B*C, C*C} which is the same as ‘npa2’ for
3 parties. [[]] encodes the identity element.</p>
<ul class="simple">
<li><p><cite>List[sympy.core.symbol.Symbol]</cite>: we can fully specify the generating set by</p></li>
</ul>
<p>giving a list of symbolic operators built from the measurement
operators in <cite>self.measurements</cite>. This list needs to have the
identity <cite>sympy.S.One</cite> as the first element.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="causalinflation.quantum.InflationSDP.InflationSDP.set_distribution">
<code class="sig-name descname">set_distribution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">use_lpi_constraints</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/causalinflation/quantum/InflationSDP.html#InflationSDP.set_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.InflationSDP.InflationSDP.set_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Set numerically the knowable moments and semiknowable moments according
to the probability distribution specified, p. If p is None, or the user
doesn’t pass any argument to set_distribution, then this is understood
as a request to delete information about past distributions. If p containts
elements that are either None or nan, then this is understood as leaving
the corresponding variable free in the SDP approximation.
:param p: Multidimensional array encoding the probability
:type p: np.ndarray
:param vector:
:param which is called as p[a:
:param b:
:param c:
:param …:
:param x:
:param y:
:param z:
:param …] where a:
:param b:
:param c:
:param …:
:param are outputs and x: even if the inputs have
:param y: even if the inputs have
:param z: even if the inputs have
:param … are inputs. Note: even if the inputs have
:param cardinality 1:
:param they must still be specified:
:param and the corresponding:
:param axis dimensions are 1.:
:param use_lpi_constraints: Specification whether linearized
:type use_lpi_constraints: bool
:param polynomial constraints: 2203.16543)
:type polynomial constraints: see, e.g., Eq. (D6
:param will be imposed or not.:</p>
</dd></dl>

<dl class="py method">
<dt id="causalinflation.quantum.InflationSDP.InflationSDP.set_objective">
<code class="sig-name descname">set_objective</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">objective</span><span class="p">:</span> <span class="n">sympy.core.symbol.Symbol</span></em>, <em class="sig-param"><span class="n">direction</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'max'</span></em><span class="sig-paren">)</span> &#x2192; None<a class="reference internal" href="_modules/causalinflation/quantum/InflationSDP.html#InflationSDP.set_objective"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.InflationSDP.InflationSDP.set_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>Set or change the objective function of the polynomial optimization
problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>objective</strong> (<em>sympy.core.symbol.Symbol</em>) – Describes the objective function.</p></li>
<li><p><strong>direction</strong> (<em>str</em><em>, </em><em>optional</em>) – Direction of the optimization (max/min), by default ‘max’</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="causalinflation.quantum.InflationSDP.InflationSDP.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">interpreter</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'MOSEKFusion'</span></em>, <em class="sig-param"><span class="n">feas_as_optim</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">solverparameters</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/causalinflation/quantum/InflationSDP.html#InflationSDP.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.InflationSDP.InflationSDP.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Call a solver on the SDP relaxation. Upon successful solution, it
returns the primal and dual objective values along with the solution
matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>interpreter</strong> (<em>str</em><em>, </em><em>optional</em>) – The solver to be called, by default ‘MOSEKFusion’.</p></li>
<li><p><strong>feas_as_optim</strong> (<em>bool</em><em>, </em><em>optional</em>) – <dl class="simple">
<dt>Instead of solving the feasibility problem</dt><dd><ol class="arabic simple">
<li><p>find vars such that Gamma &gt;= 0</p></li>
</ol>
</dd>
<dt>setting this label to True solves instead the problem</dt><dd><ol class="arabic simple" start="2">
<li><p>max lambda such that Gamma - lambda*Id &gt;= 0.</p></li>
</ol>
</dd>
</dl>
<p>The correspondence is that the result of (2) is positive if (1) is
feasible and negative otherwise. By default False.</p>
</p></li>
<li><p><strong>solverparameters</strong> (<em>_type_</em><em>, </em><em>optional</em>) – Extra parameters to be sent to the solver, by default None.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="causalinflation.quantum.InflationSDP.InflationSDP.write_to_file">
<code class="sig-name descname">write_to_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/causalinflation/quantum/InflationSDP.html#InflationSDP.write_to_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.InflationSDP.InflationSDP.write_to_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports the problem to a file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str</em>) – Name of the exported file. If no file format is
specified, it defaults to sparse SDPA format.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-causalinflation.quantum.fast_npa">
<span id="causalinflation-quantum-fast-npa-module"></span><h2>causalinflation.quantum.fast_npa module<a class="headerlink" href="#module-causalinflation.quantum.fast_npa" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="causalinflation.quantum.fast_npa.A_lessthan_B">
<code class="sig-prename descclassname">causalinflation.quantum.fast_npa.</code><code class="sig-name descname">A_lessthan_B</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em class="sig-param"><span class="n">B</span><span class="p">:</span> <span class="n">numpy.array</span></em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/causalinflation/quantum/fast_npa.html#A_lessthan_B"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.fast_npa.A_lessthan_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares two letters/measurement operators lexicographically.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.array</em>) – Measurement operator encoded as a 1D array.</p></li>
<li><p><strong>B</strong> (<em>np.array</em>) – Measurement operator encoded as a 1D array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if A is less than B.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.fast_npa.calculate_momentmatrix">
<code class="sig-prename descclassname">causalinflation.quantum.fast_npa.</code><code class="sig-name descname">calculate_momentmatrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cols</span><span class="p">:</span> <span class="n">List</span></em>, <em class="sig-param"><span class="n">names</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">0</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>numpy.ndarray<span class="p">, </span>Dict<span class="p">]</span><a class="reference internal" href="_modules/causalinflation/quantum/fast_npa.html#calculate_momentmatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.fast_npa.calculate_momentmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the moment matrix.</p>
<p>Takes as input the generating set {mon_i}_i encoded as a list of monomials.
Each monomial is a matrix where each row is an operator and the columns
specify the operator labels/indices. The moment matrix is the inner product
between all possible pairs of elements from the generating set. The program
outputs the moment matrix as a 2d array. Entry (i,j) of the moment matrix
stores the index of the monomial that is the result of the dot product
mon_i^dagger * mon_j after applying the substitutions. The program returns
the moment matrix and the dictionary mapping each monomial in string
representation to its integer representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cols</strong> (<em>List</em>) – List of np.ndarray representing the generating set.</p></li>
<li><p><strong>names</strong> (<em>np.ndarray</em>) – The string names of each party.</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em>) – _description_, by default 0</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The moment matrix, where each entry (i,j) stores the
integer representation of a monomial. The Dict is a
mapping from string representation of monomial to integer
representation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[np.ndarray, Dict]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.fast_npa.calculate_momentmatrix_commuting">
<code class="sig-prename descclassname">causalinflation.quantum.fast_npa.</code><code class="sig-name descname">calculate_momentmatrix_commuting</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cols</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">names</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">0</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/fast_npa.html#calculate_momentmatrix_commuting"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.fast_npa.calculate_momentmatrix_commuting" title="Permalink to this definition">¶</a></dt>
<dd><p>See description of ‘calculate_momentmatrix’. The same, but we further
assume everything commutes with everything.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cols</strong> (<em>np.ndarray</em>) – List of np.ndarray representing the generating set.</p></li>
<li><p><strong>names</strong> (<em>np.ndarray</em>) – The string names of each party.</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em>) – How descriptive the prints are, by default 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The moment matrix, where each entry (i,j) stores the
integer representation of a monomial. The Dict is a a
mapping from string representation of monomial to integer
representation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[np.ndarray, Dict]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.fast_npa.commuting">
<code class="sig-prename descclassname">causalinflation.quantum.fast_npa.</code><code class="sig-name descname">commuting</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">letter1</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em class="sig-param"><span class="n">letter2</span><span class="p">:</span> <span class="n">numpy.array</span></em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/causalinflation/quantum/fast_npa.html#commuting"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.fast_npa.commuting" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if two letters/operators commute.</p>
<p>TODO accept arbitrary commutation rules.
Currently this only takes into accounts commutation coming of inflation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>letter1</strong> (<em>np.array</em>) – Tuple of integers representing an operator.</p></li>
<li><p><strong>letter2</strong> (<em>np.array</em>) – Tuple of integers representing an operator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>If they commute or not.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>A^11_00 commutes with A^22_00
&gt;&gt;&gt; commuting(np.array([1, 1, 1, 0, 0]), np.array([1, 2, 2, 0, 0]))
True</p>
<p>A^11_00 does not commute with A^12_00 as they overlap on source 1.
&gt;&gt;&gt; commuting(np.array([1, 1, 1, 0, 0]), np.array([1, 1, 2, 0, 0]))
False</p>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.fast_npa.dot_mon">
<code class="sig-prename descclassname">causalinflation.quantum.fast_npa.</code><code class="sig-name descname">dot_mon</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mon1</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">mon2</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/fast_npa.html#dot_mon"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.fast_npa.dot_mon" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns ((mon1)^dagger)*mon2.</p>
<p>For hermitian operators this is the same as reversed(mon1)*mon2.
Since all parties commute, the output is ordered by parties. We do
not assume any other commutation rules.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mon1</strong> (<em>np.ndarray</em>) – Monomial as a numpy array.</p></li>
<li><p><strong>mon2</strong> (<em>np.ndarray</em>) – Monomial as a numpy array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Output monomial ordered by parties.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mon1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mon2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dot_mon</span><span class="p">(</span><span class="n">mon1</span><span class="p">,</span> <span class="n">mon2</span><span class="p">)</span>
<span class="go">np.array([[4,5,6],[1,2,3],[7,8,9]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.fast_npa.dot_mon_commuting">
<code class="sig-prename descclassname">causalinflation.quantum.fast_npa.</code><code class="sig-name descname">dot_mon_commuting</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mon1</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">mon2</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/fast_npa.html#dot_mon_commuting"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.fast_npa.dot_mon_commuting" title="Permalink to this definition">¶</a></dt>
<dd><p>A faster implementation of <cite>dot_mon</cite> that assumes that all
operators commute. This implies we order everything lexiographically.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mon1</strong> (<em>np.ndarray</em>) – Monomial as a numpy array.</p></li>
<li><p><strong>mon2</strong> (<em>np.ndarray</em>) – Monomial as a numpy array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Returns (mon1)^dagger*mon2 with the assumption that
everything commutes with everything.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.fast_npa.mon_is_zero">
<code class="sig-prename descclassname">causalinflation.quantum.fast_npa.</code><code class="sig-name descname">mon_is_zero</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mon</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/causalinflation/quantum/fast_npa.html#mon_is_zero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.fast_npa.mon_is_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Function which checks if there is a product of two orthogonal projectors,
and returns True if so.</p>
<p>_extended_summary_</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mon</strong> (<em>np.ndarray</em>) – Input monomial as 2d array.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the monomial is zero, False otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.fast_npa.mon_lessthan_mon">
<code class="sig-prename descclassname">causalinflation.quantum.fast_npa.</code><code class="sig-name descname">mon_lessthan_mon</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mon1</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">mon2</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/causalinflation/quantum/fast_npa.html#mon_lessthan_mon"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.fast_npa.mon_lessthan_mon" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares two monomials and returns True if mon1 &lt; mon2 in lexicographic
order.</p>
<p>It flattens then 2D array representing the monomial to and uses
the function A_lessthan_B.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mon1</strong> (<em>np.ndarray</em>) – Input monomial as a 2d array.</p></li>
<li><p><strong>mon2</strong> (<em>np.ndarray</em>) – Input monomial as a 2d array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if mon1 &lt; mon2 in lexicographic order.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.fast_npa.mon_lexsorted">
<code class="sig-prename descclassname">causalinflation.quantum.fast_npa.</code><code class="sig-name descname">mon_lexsorted</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mon</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/fast_npa.html#mon_lexsorted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.fast_npa.mon_lexsorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a monomial sorted lexicographically.</p>
<p>The sorting keys are as follows. The first key is the parties, the second
key is the inflation indices and the last keys are the input and output
cardinalities. More informally, once we sorted all the parties together,
within a party group we group all operators with the same inflation-copy
index for the first source together, and within this group we group all
operators with the same inflation-copy index for the second source
together and so on until the last keys.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mon</strong> (<em>np.ndarray</em>) – Monomial as a numpy array.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Sorted monomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.fast_npa.mon_sorted_by_parties">
<code class="sig-prename descclassname">causalinflation.quantum.fast_npa.</code><code class="sig-name descname">mon_sorted_by_parties</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mon</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/fast_npa.html#mon_sorted_by_parties"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.fast_npa.mon_sorted_by_parties" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by parties the monomial, i.e., sort by the first column in
the 2d representation of the monomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mon</strong> (<em>np.ndarray</em>) – Input monomial as 2d array.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Sorted monomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mon_sorted_by_parties</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span><span class="o">...</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="o">...</span><span class="p">]]))</span>
<span class="go">np.array([[1,...],[3,...],[4,...]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.fast_npa.nb_apply_substitutions">
<code class="sig-prename descclassname">causalinflation.quantum.fast_npa.</code><code class="sig-name descname">nb_apply_substitutions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mon_in</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/fast_npa.html#nb_apply_substitutions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.fast_npa.nb_apply_substitutions" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply substitutions to a monomial.</p>
<p>Currently it only supports commutations arising from operators having
completely different support. It goes in a loop applying the substitutions
until it reaches a fixed point, if it finds two letters that commute and
are not in lexicographic ordering. This function does a single loop from
the first row to the last applying all substitutions along the way and
then it returns.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mon_in</strong> (<em>np.ndarray</em>) – Input monomial as a 2d array.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Simplified input monomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.fast_npa.remove_projector_squares">
<code class="sig-prename descclassname">causalinflation.quantum.fast_npa.</code><code class="sig-name descname">remove_projector_squares</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mon</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/fast_npa.html#remove_projector_squares"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.fast_npa.remove_projector_squares" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplify the monomial by removing the squares. This is because we
assume projectors, P^2=P.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mon</strong> (<em>np.ndarray</em>) – Input monomial as 2d array.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Simplified monomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.fast_npa.reverse_mon">
<code class="sig-prename descclassname">causalinflation.quantum.fast_npa.</code><code class="sig-name descname">reverse_mon</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mon</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/fast_npa.html#reverse_mon"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.fast_npa.reverse_mon" title="Permalink to this definition">¶</a></dt>
<dd><p>Output the monomial reversed, which means reverse the row of the 2d
matrix representing the monomial. This represents the complex conjugate
of the monomial, but we assume they are Hermitian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mon</strong> (<em>np.ndarray</em>) – Input monomial as 2d array.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Reversed monomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reverse_mon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="o">...</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="o">...</span><span class="p">]]))</span>
<span class="go">np.array([[3,...],[4,...],[1,...]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.fast_npa.to_canonical">
<code class="sig-prename descclassname">causalinflation.quantum.fast_npa.</code><code class="sig-name descname">to_canonical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mon</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/fast_npa.html#to_canonical"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.fast_npa.to_canonical" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply substitutions to a monomial until it stops changing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mon</strong> (<em>np.ndarray</em>) – Input monomial as a 2d array.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Monomial in canonical form w.r.t some lexicographic
ordering.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.fast_npa.to_name">
<code class="sig-prename descclassname">causalinflation.quantum.fast_npa.</code><code class="sig-name descname">to_name</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">monomial_numbers</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">parties_names</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/causalinflation/quantum/fast_npa.html#to_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.fast_npa.to_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the 2d array representation of a monoial to a string.</p>
<p>_extended_summary_</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>monomial_numbers</strong> (<em>np.ndarray</em>) – Input monomial as 2d array.</p></li>
<li><p><strong>parties_names</strong> (<em>np.ndarray</em>) – Array of strings representing the parties.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>String representation of the monomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">to_name</span><span class="p">([[</span><span class="mi">1</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;bb&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;Z&#39;</span><span class="p">])</span>
<span class="go">&#39;a_1_0_3*Z_1_2_6*bb_3_3_4&#39;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-causalinflation.quantum.general_tools">
<span id="causalinflation-quantum-general-tools-module"></span><h2>causalinflation.quantum.general_tools module<a class="headerlink" href="#module-causalinflation.quantum.general_tools" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="causalinflation.quantum.general_tools.apply_source_perm_monomial">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">apply_source_perm_monomial</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">monomial</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">source</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">permutation</span><span class="p">:</span> <span class="n">List</span></em>, <em class="sig-param"><span class="n">commuting</span><span class="p">:</span> <span class="n">bool</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#apply_source_perm_monomial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.apply_source_perm_monomial" title="Permalink to this definition">¶</a></dt>
<dd><p>This applies a source swap to a monomial.</p>
<p>We assume in the monomial that all operators COMMUTE with each other.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>monomial</strong> (<em>np.ndarray</em>) – Input monomial in 2d array format.</p></li>
<li><p><strong>source</strong> (<em>int</em>) – The source that is being swapped.</p></li>
<li><p><strong>permutation</strong> (<em>List</em>) – The permutation of the copies of the specified source</p></li>
<li><p><strong>commuting</strong> (<em>bool</em>) – Whether all the involved operators commute or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Input monomial with the specified source swapped.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.apply_source_permutation_coord_input">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">apply_source_permutation_coord_input</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">columns</span><span class="p">:</span> <span class="n">List<span class="p">[</span>numpy.ndarray<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">source</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">permutation</span><span class="p">:</span> <span class="n">List<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">commuting</span><span class="p">:</span> <span class="n">bool</span></em>, <em class="sig-param"><span class="n">substitutions</span><span class="p">:</span> <span class="n">Dict<span class="p">[</span>sympy.core.symbol.Symbol<span class="p">, </span>sympy.core.symbol.Symbol<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">flatmeas</span><span class="p">:</span> <span class="n">List<span class="p">[</span>sympy.core.symbol.Symbol<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">measnames</span><span class="p">:</span> <span class="n">List<span class="p">[</span>str<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">names</span><span class="p">:</span> <span class="n">List<span class="p">[</span>str<span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; List<span class="p">[</span>sympy.core.symbol.Symbol<span class="p">]</span><a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#apply_source_permutation_coord_input"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.apply_source_permutation_coord_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a specific source permutation to the list of operators used to
define the moment matrix. Outputs the permuted list of operators.
The operators are enconded as lists of numbers denoting
[party, source_1_copy, source_2_copy, …, input, output]
A product of operators is a list of such lists transformed into a
np.ndarray.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>columns</strong> (<em>List</em><em>[</em><em>np.ndarray</em><em>]</em>) – Generating set as a list of monomials in 2d array format.</p></li>
<li><p><strong>source</strong> (<em>int</em>) – Source that is being swapped.</p></li>
<li><p><strong>permutation</strong> (<em>List</em><em>[</em><em>int</em><em>]</em>) – Permutation of the copies of the specified source.</p></li>
<li><p><strong>commuting</strong> (<em>bool</em>) – Whether the operators commute or not.</p></li>
<li><p><strong>substitutions</strong> (<em>Dict</em><em>[</em><em>sympy.core.symbol.Symbol</em><em>, </em><em>sympy.core.symbol.Symbol</em><em>]</em>) – Dictionary of substitutions to be applied to the operators.</p></li>
<li><p><strong>flatmeas</strong> (<em>List</em><em>[</em><em>sympy.core.symbol.Symbol</em><em>]</em>) – List of measurements in the form of symbolic operators.</p></li>
<li><p><strong>measnames</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – Names of the measurements in <cite>flatmeas</cite>.</p></li>
<li><p><strong>names</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – String names of the parties.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List of operators with the specified source permuted.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[np.ndarray]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.apply_source_permutation_monomial">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">apply_source_permutation_monomial</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">monomial</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">source</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">permutation</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#apply_source_permutation_monomial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.apply_source_permutation_monomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a source permutation to a single monomial.</p>
<p>SPEED NOTE: if you want to apply a simple source swap as opposed
to an arbitrary permutation, use apply_source_swap_monomial instead,
as it is 25x faster.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>monomial</strong> (<em>np.ndarray</em>) – Input monomial in 2d array format.</p></li>
<li><p><strong>source</strong> (<em>int</em>) – Source that is being swapped.</p></li>
<li><p><strong>permutation</strong> (<em>np.ndarray</em>) – Permutation of the copies of the specified source.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Monomial with the specified source permuted.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.apply_source_swap_monomial">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">apply_source_swap_monomial</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">monomial</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">source</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">copy1</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">copy2</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#apply_source_swap_monomial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.apply_source_swap_monomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a swap of two sources to a monomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>monomial</strong> (<em>np.ndarray</em>) – 2d array representation of a monomial.</p></li>
<li><p><strong>source</strong> (<em>int</em>) – Integer in values [0, …, nr_sources]</p></li>
<li><p><strong>copy1</strong> (<em>int</em>) – Represents the copy of the source that swaps with copy2</p></li>
<li><p><strong>copy2</strong> (<em>int</em>) – Represents the copy of the source that swaps with copy1</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The new monomial with swapped sources.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">monomial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_source_swap_monomial</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="go">                                         [2, 1, 3, 0, 0, 0]]),</span>
<span class="go">                                         1,  # source</span>
<span class="go">                                         2,  # copy1</span>
<span class="go">                                         3)  # copy2</span>
<span class="go">array([[1, 0, 3, 1, 0, 0],</span>
<span class="go">       [2, 1, 2, 0, 0, 0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.as_ordered_factors_for_powers">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">as_ordered_factors_for_powers</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">monomial</span><span class="p">:</span> <span class="n">sympy.core.symbol.Symbol</span></em><span class="sig-paren">)</span> &#x2192; List<span class="p">[</span>sympy.core.symbol.Symbol<span class="p">]</span><a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#as_ordered_factors_for_powers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.as_ordered_factors_for_powers" title="Permalink to this definition">¶</a></dt>
<dd><p>If we have powers of a monomial, such as A**3, return a list with
the factors, [A, A, A].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>monomial</strong> (<em>sympy.core.symbol.Symbol</em>) – Symbolic monomial, possible with powers.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List of all the symbolic factors, with the powers expanded.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[sympy.core.symbol.Symbol]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.canonicalize">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">canonicalize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">list_of_operators</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">measurements</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>List<span class="p">[</span>sympy.core.symbol.Symbol<span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">substitutions</span><span class="p">:</span> <span class="n">Dict</span></em>, <em class="sig-param"><span class="n">parties_names</span><span class="p">:</span> <span class="n">List<span class="p">[</span>str<span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; List<span class="p">[</span>List<span class="p">[</span>int<span class="p">]</span><span class="p">]</span><a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#canonicalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Brings a monomial, written as a list of lists of indices, into canonical
form. The canonical form depends on the commuting nature of the operators.
If all operators commute, it is a plain lexicographic ordering.</p>
<p>TODO: WARNING! This function goes through symbolic substitutions. This is slow
and will be removed in subsequent versions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>list_of_operators</strong> (<em>List</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em>) – The input monomial.</p></li>
<li><p><strong>measurements</strong> (<em>List</em><em>[</em><em>List</em><em>[</em><em>List</em><em>[</em><em>sympy.core.symbol.Symbol</em><em>]</em><em>]</em><em>]</em>) – All the symbolic measurement operators.</p></li>
<li><p><strong>substitutions</strong> (<em>Dict</em>) – Dictionary of symbolic substitutions to be applied to the monomial.</p></li>
<li><p><strong>parties_names</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – List of party names.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The monomial in canonical form.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[List[int]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.clean_coefficients">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">clean_coefficients</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coefficients</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em class="sig-param"><span class="n">chop_tol</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">1e-10</span></em>, <em class="sig-param"><span class="n">round_decimals</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">3</span></em><span class="sig-paren">)</span> &#x2192; numpy.array<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#clean_coefficients"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.clean_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean the list of coefficients in a certificate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coefficients</strong> (<em>numpy.array</em>) – The list of coefficients.</p></li>
<li><p><strong>chop_tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Coefficients in the dual certificate smaller in absolute value are
set to zero. Defaults to 1e-10.</p></li>
<li><p><strong>round_decimals</strong> (<em>int</em><em>, </em><em>optional</em>) – Coefficients that are not set to zero are rounded to the number
of decimals specified. Defaults to 3.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The cleaned-up coefficients.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.factorize_monomial">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">factorize_monomial</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">monomial</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#factorize_monomial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.factorize_monomial" title="Permalink to this definition">¶</a></dt>
<dd><p>This function splits a moment/expectation value into products of
moments according to the support of the operators within the moment.</p>
<p>The moment is encoded as a 2d array where each row is an operator.
If monomial=A*B*C*B then row 1 is A, row 2 is B, row 3 is C and row 4 is B.
In each row, the columns encode the following information:</p>
<dl class="simple">
<dt>First column:       The party index, <em>starting from 1</em>.</dt><dd><p>(1 for A, 2 for B, etc.)</p>
</dd>
<dt>Last two columns:   The input x, starting from zero and then the</dt><dd><p>output a, starting from zero.</p>
</dd>
<dt>In between:         This encodes the support of the operator. There</dt><dd><p>are as many columns as sources/quantum states.
Column j represents source j-1 (-1 because the 1st
col is the party). If the value is 0, then this
operator does not measure this source. If the value
is for e.g. 2, then this operator is acting on
copy 2 of source j-1.</p>
</dd>
</dl>
<p>The output is a list of lists, where each list represents another
monomial s.t. their product is equal to the original monomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>monomial</strong> (<em>np.ndarray</em>) – Monomial encoded as a 2d array where each row is an operator.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of lists, where each list represents the monomial factors.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">monomial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="go">                         [2, 1, 0, 2, 0, 0],</span>
<span class="go">                         [1, 0, 3, 3, 0, 0],</span>
<span class="go">                         [3, 3, 5, 0, 0, 0],</span>
<span class="go">                         [3, 1, 4, 0, 0, 0],</span>
<span class="go">                         [3, 6, 6, 0, 0, 0],</span>
<span class="go">                         [3, 4, 5, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factorised</span> <span class="o">=</span> <span class="n">factorize_monomial</span><span class="p">(</span><span class="n">monomial</span><span class="p">)</span>
<span class="go">[array([[1, 0, 1, 1, 0, 0]]),</span>
<span class="go"> array([[1, 0, 3, 3, 0, 0]]),</span>
<span class="go"> array([[2, 1, 0, 2, 0, 0],</span>
<span class="go">        [3, 1, 4, 0, 0, 0]]),</span>
<span class="go"> array([[3, 3, 5, 0, 0, 0],</span>
<span class="go">        [3, 4, 5, 0, 0, 0]]),</span>
<span class="go"> array([[3, 6, 6, 0, 0, 0]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.factorize_monomials">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">factorize_monomials</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">monomials_as_numbers</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">0</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#factorize_monomials"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.factorize_monomials" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies factorize_momonial to each monomial in the input list
of monomials.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>monomials_as_numbers</strong> (<em>np.ndarray</em>) – An ndarray of type object where each row has the integer
representation of a monomial in the 1st column and in the 2nd
column a monomial in matrix form (each row is an operator
and each column has the operator indices).</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em>) – Whether to print progress bar, by default 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Same as monomials_as_numbers but with the
factorized monomials.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.find_permutation">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">find_permutation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">list1</span><span class="p">:</span> <span class="n">List</span></em>, <em class="sig-param"><span class="n">list2</span><span class="p">:</span> <span class="n">List</span></em><span class="sig-paren">)</span> &#x2192; List<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#find_permutation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.find_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the permutation that transforms list2 in list1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>list1</strong> (<em>List</em>) – First input list.</p></li>
<li><p><strong>list2</strong> (<em>List</em>) – Second input list.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Permutation the brings list2 to list1.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>Exception</strong> – If the lengths are different, or if the elements of the two lists are
    different.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.from_coord_to_sym">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">from_coord_to_sym</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ordered_cols_coord</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>List<span class="p">[</span>int<span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">names</span><span class="p">:</span> <span class="n">str</span></em>, <em class="sig-param"><span class="n">n_sources</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">measurements</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>List<span class="p">[</span>sympy.core.symbol.Symbol<span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; List<span class="p">[</span>sympy.core.symbol.Symbol<span class="p">]</span><a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#from_coord_to_sym"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.from_coord_to_sym" title="Permalink to this definition">¶</a></dt>
<dd><p>Go from the output of build_columns to a list of symbolic operators</p>
<p>TODO: change name to cols_num2sym</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ordered_cols_coord</strong> (<em>List</em><em>[</em><em>List</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em><em>]</em>) – Generating set as a list of monomials represented as an array.</p></li>
<li><p><strong>names</strong> (<em>str</em>) – Names of each party.</p></li>
<li><p><strong>n_sources</strong> (<em>int</em>) – Number of sources.</p></li>
<li><p><strong>measurements</strong> (<em>List</em><em>[</em><em>List</em><em>[</em><em>List</em><em>[</em><em>sympy.core.symbol.Symbol</em><em>]</em><em>]</em><em>]</em>) – List of symbolic operators representing the measurements. The list is
nested such that the first index corresponds to the party, the
second index to the measurement, and the third index to the outcome.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The generating set but with symbolic monomials.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[sympy.core.symbol.Symbol]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.from_indices_to_operators">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">from_indices_to_operators</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">monomial_list</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">measurements</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>List<span class="p">[</span>sympy.core.symbol.Symbol<span class="p">]</span><span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; sympy.core.symbol.Symbol<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#from_indices_to_operators"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.from_indices_to_operators" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms a monomial, expressed as a list of lists of indices,
into its associated operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>monomial_list</strong> (<em>List</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em>) – Input monomal in array form.</p></li>
<li><p><strong>measurements</strong> (<em>List</em><em>[</em><em>List</em><em>[</em><em>List</em><em>[</em><em>sympy.core.symbol.Symbol</em><em>]</em><em>]</em><em>]</em>) – All the measurement operators.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Symbolic monomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Symbolic</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.from_numbers_to_flat_tuples">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">from_numbers_to_flat_tuples</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lista</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; List<span class="p">[</span>Tuple<span class="p">[</span>int<span class="p">]</span><span class="p">]</span><a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#from_numbers_to_flat_tuples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.from_numbers_to_flat_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Flatten all monomials in the list represented as lists of lists to a
flat tuple.</p>
<p>This is useful for dictionaries, as list of lists are not hashable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>list</strong> (<em>List</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em>) – List of monomials encoded as lists of lists (or array of arrays).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List of monomials encoded as flat tuples of integers.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[Tuple[int]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.generate_commuting_measurements">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">generate_commuting_measurements</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">party</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">label</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span> &#x2192; List<span class="p">[</span>List<span class="p">[</span>List<span class="p">[</span>sympy.core.symbol.Symbol<span class="p">]</span><span class="p">]</span><span class="p">]</span><a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#generate_commuting_measurements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.generate_commuting_measurements" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the list of symbolic variables representing the measurements
for a given party. The variables are treated as commuting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>party</strong> (<em>int</em>) – Configuration indicating the configuration of m measurements and
d outcomes for each measurement. It is a list with m integers,
each of them representing the number of outcomes of the corresponding
measurement.</p></li>
<li><p><strong>label</strong> (<em>str</em>) – label to represent the given party</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List of measurements.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[List[List[sympy.core.symbol.Symbol]]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.generate_noncommuting_measurements">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">generate_noncommuting_measurements</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">party</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">label</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span> &#x2192; List<span class="p">[</span>List<span class="p">[</span>List<span class="p">[</span>sympy.core.symbol.Symbol<span class="p">]</span><span class="p">]</span><span class="p">]</span><a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#generate_noncommuting_measurements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.generate_noncommuting_measurements" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the list of sympy.core.symbol.Symbol variables representing the measurements
for a given party. The variables are treated as non-commuting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>party</strong> (<em>int</em>) – Configuration indicating the configuration of m measurements and
d outcomes for each measurement. It is a list with m integers,
each of them representing the number of outcomes of the corresponding
measurement.</p></li>
<li><p><strong>label</strong> (<em>str</em>) – Label to represent the given party.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List of measurements.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[List[List[sympy.core.symbol.Symbol]]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.is_knowable">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">is_knowable</code><span class="sig-paren">(</span><em class="sig-param">monomial: NewType.&lt;locals&gt;.new_type</em>, <em class="sig-param">hypergraph_scenario: numpy.ndarray</em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#is_knowable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.is_knowable" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines whether a given atomic monomial (which cannot be factorized
into smaller disconnected components) admits an identification with a
monomial of the original scenario.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>monomial</strong> (<em>Union</em><em>[</em><em>List</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em><em>, </em><em>np.ndarray</em><em>]</em>) – List of operators, denoted each by a list of indices</p></li>
<li><p><strong>hypergraph_scenario</strong> (<em>np.ndarray</em>) – Binary matrix representing the scenario.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>bool stating whether the monomial is knowable or not</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.is_physical">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">is_physical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">monomial_in</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>List<span class="p">[</span>List<span class="p">[</span>int<span class="p">]</span><span class="p">]</span><span class="p">, </span>numpy.ndarray<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">sandwich_positivity</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#is_physical"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.is_physical" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines whether a monomial is physical/positive. It is positive
if it is a probability (i.e., &gt;0) but we do not  know its exact value.</p>
<p>This code also supports the detection of “sandwiches”, i.e., monomials
of the form
$langle psi | A_1 A_2 A_1 | psi rangle$
where $A_1$ and $A_2$ do not commute. In principle we do not know the
value of this term. However, note that $A_1$ can be absorbed into
$| psi rangle$ forming an unnormalised quantum state
$| psi’ rangle$, thus
$langle psi’ | A_2 | psi’ rangle$
Note that while we know the value $langle psi | A_2 | psi rangle$
we do not know $langle psi’ | A_2 | psi’ rangle$ because of the
unknown normalisation, however we know it must be positive, thus
$langle psi | A_1 A_2 A_1 | psi rangle geq 0$.
This simple example can be extended to various layers of sandwiching.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>monomial_in</strong> (<em>Union</em><em>[</em><em>List</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em><em>, </em><em>np.ndarray</em><em>]</em>) – Input monomial in 2d array format.</p></li>
<li><p><strong>sandwich_positivity</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to consider sandiwching, by default False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Returns whether the monomial is positive or not.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.label_knowable_and_unknowable">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">label_knowable_and_unknowable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">monomials_factors</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">hypergraph</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#label_knowable_and_unknowable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.label_knowable_and_unknowable" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the list of monomials factorised, it labels each
monomial into knowable, semiknowable and unknowable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>monomials_factors_input</strong> (<em>np.ndarray</em>) – Ndarray of factorised monomials. Each row encodes the integer
representation and the factors of the monomial.</p></li>
<li><p><strong>hypergraph</strong> (<em>np.ndarray</em>) – The hypergraph of the network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Array of the same size as the input, with the labels of each monomial.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.monomialset_name2num">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">monomialset_name2num</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">monomials</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">names</span><span class="p">:</span> <span class="n">List<span class="p">[</span>str<span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#monomialset_name2num"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.monomialset_name2num" title="Permalink to this definition">¶</a></dt>
<dd><p>Change each monomial in the list of monomials from string to matrix
representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>monomials</strong> (<em>np.ndarray</em>) – Input monomials list.</p></li>
<li><p><strong>names</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – List of party names</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Same dimensions as input monomials, but each monomial is in
string format.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.monomialset_num2name">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">monomialset_num2name</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">monomials_factors</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">names</span><span class="p">:</span> <span class="n">List<span class="p">[</span>str<span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#monomialset_num2name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.monomialset_num2name" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the list of monomials from a list of 2d arrays to a list of strings.</p>
<p>_extended_summary_</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>monomials_factors</strong> (<em>np.ndarray</em>) – List of monomials.</p></li>
<li><p><strong>names</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – names[i] is the name of party i+1 (parties in [1,2,3,4…]).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Returns the input with the monomials replaced by their
string representation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.mul">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">mul</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lst</span><span class="p">:</span> <span class="n">List</span></em><span class="sig-paren">)</span> &#x2192; Any<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#mul"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply all elements of a list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lst</strong> (<em>List</em>) – Input list with elements that have a supported ‘*’ multiplication.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Product of all elements.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mul</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="n">A_1</span><span class="p">,</span> <span class="n">B_2</span><span class="p">])</span>
<span class="go">2*A_1*B_2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.nb_first_index">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">nb_first_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">array</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">item</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; int<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#nb_first_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.nb_first_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first index of an item in an array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>np.ndarray</em>) – The array to search.</p></li>
<li><p><strong>item</strong> (<em>float</em>) – The item to find.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The index where the first item is found.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb_first_index</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.nb_unique">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">nb_unique</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>numpy.ndarray<span class="p">, </span>numpy.ndarray<span class="p">]</span><a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#nb_unique"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.nb_unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the unique elements in an array without sorting
and in order of appearance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arr</strong> (<em>np.ndarray</em>) – The array to search.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The unique values unsorted and their indices.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[np.ndarray, np.ndarray]</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nb_unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span>
<span class="go">(array([1, 3, 2, 5, 4], dtype=int16), array([0, 1, 3, 5, 6], dtype=int16))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.phys_mon_1_party_of_given_len">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">phys_mon_1_party_of_given_len</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">hypergraph</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">inflevels</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em class="sig-param"><span class="n">party</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">max_monomial_length</span><span class="p">:</span> <span class="n">int</span></em>, <em class="sig-param"><span class="n">settings_per_party</span><span class="p">:</span> <span class="n">List<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">outputs_per_party</span><span class="p">:</span> <span class="n">List<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">names</span><span class="p">:</span> <span class="n">List<span class="p">[</span>str<span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; List<span class="p">[</span>numpy.ndarray<span class="p">]</span><a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#phys_mon_1_party_of_given_len"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.phys_mon_1_party_of_given_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates all possible positive monomials given a scenario and a
maximum length.</p>
<p>Note that the maximum length cannot be greater than the minimum number
of copies for each source that the party has access to. For example,
if party 2 has access to 3 sources, the first has 3 copies, the second
4 copies and the third 5 copies, the maximum length cannot be greater
than 3. This is because the extra operators will not commute with the
ones before as they will be sharing support (unless we also consider
entangling vs. separable measurements!)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hypergraph</strong> (<em>np.ndarray</em>) – Hypergraph of the scenario.</p></li>
<li><p><strong>inflevels</strong> (<em>np.array</em>) – The number of copies of each source in the inflated scenario.</p></li>
<li><p><strong>party</strong> (<em>int</em>) – Party index. NOTE: starting from 0!</p></li>
<li><p><strong>max_monomial_length</strong> (<em>int</em>) – The maximum number of operators in the monomial.</p></li>
<li><p><strong>settings_per_party</strong> (<em>List</em><em>[</em><em>int</em><em>]</em>) – List containing the cardinality of the input/measurement setting
of each party.</p></li>
<li><p><strong>outputs_per_party</strong> (<em>List</em><em>[</em><em>int</em><em>]</em>) – List containing the cardinality of the output/measurement outcome
of each party.</p></li>
<li><p><strong>names</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – names[i] is the string name of the party i+1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An array containing all possible positive monomials of the given
length.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[np.ndarray]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.remove_sandwich">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">remove_sandwich</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">monomial</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#remove_sandwich"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.remove_sandwich" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes sandwiching/pinching from a monomial.</p>
<p>Consider more complicated sandwich scenarios:
&lt;(A_0111*A_0121*A_0111)*(A_332*A_0342*A_332)*(B_0011*B_0012)&gt;
Notice that the first parenthesis commutes with the second, but none of the
first or second commutes with the third. In this case the algorithm of
just looking at the first and last operator will not identify this
sandwich, so an easy way is to just apply factorize_monomial to the
letters from a single party, and try to identify sandwiches in
non-commuting blocks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>monomial</strong> (<em>np.ndarray</em>) – Input monomial.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Output monomial without one layer of sandwiching.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.string2prob">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">string2prob</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">term</span><span class="p">:</span> <span class="n">str</span></em>, <em class="sig-param"><span class="n">max_nr_of_parties</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span> &#x2192; sympy.core.symbol.Symbol<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#string2prob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.string2prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a string to a symbolic probability with the correct indices.
For example ‘A_0_1_0*B_0_2_3’ is converted to pAB(03|12).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>term</strong> (<em>_type_</em>) – Input monomial as a string.</p></li>
<li><p><strong>max_nr_of_parties</strong> (<em>_type_</em>) – The number of terms in the monomial.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The symbolic probability, e.g., p(00|01).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sympy.core.symbol.Symbol</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.substitute_sym_with_numbers">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">substitute_sym_with_numbers</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">symbolic_variables_to_be_given</span><span class="p">:</span> <span class="n">List<span class="p">[</span>Tuple<span class="p">[</span>int<span class="p">, </span>sympy.core.symbol.Symbol<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">settings_per_party</span><span class="p">:</span> <span class="n">List<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">outcomes_per_party</span><span class="p">:</span> <span class="n">List<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">p_vector</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; List<span class="p">[</span>Tuple<span class="p">[</span>int<span class="p">, </span>float<span class="p">]</span><span class="p">]</span><a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#substitute_sym_with_numbers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.substitute_sym_with_numbers" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitute all symbolic variables of the form ‘p(ab..|xy..)’ with
the corresponding value or marginal computed from p_vector.</p>
<p>_extended_summary_</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>symbolic_variables_to_be_given</strong> (<em>List</em><em>[</em><em>Tuple</em><em>[</em><em>int</em><em>, </em><em>sympy.core.symbol.Symbol</em><em>]</em><em>]</em>) – A list of structure […,[int, symbolic_prob],…]</p></li>
<li><p><strong>settings_per_party</strong> (<em>List</em><em>[</em><em>int</em><em>]</em>) – Measurement setting cardinality per party.</p></li>
<li><p><strong>outcomes_per_party</strong> (<em>List</em><em>[</em><em>int</em><em>]</em>) – Measurement output cardinality per party.</p></li>
<li><p><strong>p_vector</strong> (<em>np.ndarray</em>) – Probability vector indexed ad p[a,b,c,…,x,y,z…]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A nested list of type […, [int, float], …] where every
symbolic probability in the input is substituted with its numerical
value.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[Tuple[int, float]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.substitute_sym_with_value">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">substitute_sym_with_value</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">syminput</span><span class="p">:</span> <span class="n">sympy.core.symbol.Symbol</span></em>, <em class="sig-param"><span class="n">settings_per_party</span><span class="p">:</span> <span class="n">List<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">outcomes_per_party</span><span class="p">:</span> <span class="n">List<span class="p">[</span>int<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">p_vector</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#substitute_sym_with_value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.substitute_sym_with_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Function which, given a symbolic probability in the form
p(abc…|xyz…) and a probability distribution p called as
p[a,b,c,…,x,y,z,…], returns the numerical value of the
probability.</p>
<p>Note that this accepts marginals, for example, p(a|x), and
then it automatically computes all the summations over
p[a,b,c,…,x,y,z,…].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>syminput</strong> (<em>sympy.core.symbol.Symbol</em>) – Symbolic probability.</p></li>
<li><p><strong>settings_per_party</strong> (<em>List</em><em>[</em><em>int</em><em>]</em>) – Setting cardinalities per party.</p></li>
<li><p><strong>outcomes_per_party</strong> (<em>List</em><em>[</em><em>int</em><em>]</em>) – Outcome cardinalities per party.</p></li>
<li><p><strong>p_vector</strong> (<em>np.ndarray</em>) – The probability distribution of dims
(outcomes_per_party,settings_per_party).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The value of the symbolic probability (which can be a marginal)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;pA(0|1)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">substitute_sym_with_value</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">parray</span><span class="p">)</span>
<span class="go">parray[0,:,1,0].sum()</span>
</pre></div>
</div>
<p>Note that we take the first setting (=0) for marginalised parties, in the
example above, the second party is marginalised.</p>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.substitute_variable_values_in_monlist">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">substitute_variable_values_in_monlist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">variables_values</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">monomials_factors_reps</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">monomials_factors_names</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">stop_counting</span><span class="p">:</span> <span class="n">int</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#substitute_variable_values_in_monlist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.substitute_variable_values_in_monlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitues the known monomials with their known numerical value. From
this the ‘known_moments’ and lpi constraints can be extracted for the SDP.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variables_values</strong> (<em>np.ndarray</em>) – Array describing the numerical value of known moments.</p></li>
<li><p><strong>monomials_factors_reps</strong> (<em>np.ndarray</em>) – Monomials factorised, in integer representation.</p></li>
<li><p><strong>monomials_factors_names</strong> (<em>np.ndarray</em>) – Monomials factorised, in string representation.</p></li>
<li><p><strong>stop_counting</strong> (<em>int</em>) – Only consider monomials up to this index.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The monomials list with the known monomials substituted
with numerical values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.to_name">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">to_name</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">monomial_numbers</span><span class="p">:</span> <span class="n">List<span class="p">[</span>List<span class="p">[</span>int<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">parties_names</span><span class="p">:</span> <span class="n">List<span class="p">[</span>str<span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; str<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#to_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.to_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Go from lists of numbers to string representation.</p>
<p>Comments: this is much quicker (10x) if monomial_numbers is a list of
lists than if it a np.array (At least with the current implementation)!
Around 3-4 microsecs and more than 10 microsecs if input is np.array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>monomial_numbers</strong> (<em>np.ndarray</em>) – Monomial in matrix format.</p></li>
<li><p><strong>parties_names</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – List of party names.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>String representation of the input.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.to_numbers">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">to_numbers</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">monomial</span><span class="p">:</span> <span class="n">str</span></em>, <em class="sig-param"><span class="n">parties_names</span><span class="p">:</span> <span class="n">List<span class="p">[</span>str<span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; List<span class="p">[</span>List<span class="p">[</span>int<span class="p">]</span><span class="p">]</span><a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#to_numbers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.to_numbers" title="Permalink to this definition">¶</a></dt>
<dd><p>Monomial from string to matrix representation.</p>
<p>Given a monomial input in string format, return the matrix representation
where each row represents an operators and the columns are operator labels
such as party, inflation copies and input and output cardinalities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>monomial</strong> (<em>str</em>) – Monomial in string format.</p></li>
<li><p><strong>parties_names</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) – List of party names.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Monomial in list of lists format (equivalent to 2d array format by
calling np.array() on the result).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[List[int]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.to_representative">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">to_representative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mon</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em>, <em class="sig-param"><span class="n">inflevels</span><span class="p">:</span> <span class="n">numpy.array</span></em>, <em class="sig-param"><span class="n">commuting</span><span class="p">:</span> <span class="n">bool</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#to_representative"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.to_representative" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes a monomial and applies inflation
symmetries to bring it to a canonical form.</p>
<p>NOTE WARNING: Not finished!!</p>
<p>Example:
Assume the monomial is something like:
&lt; D^350_00 D^450_00 D^150_00 E^401_00 F^031_00 &gt;</p>
<p>Let us put the inflation copies as a matrix:</p>
<dl class="simple">
<dt>[[3 5 0],</dt><dd><p>[4 5 0],
[1 5 0],
[4 0 1],
[0 3 1]]</p>
</dd>
</dl>
<p>For each column we assign to the first row index 1. Then the
NEXT DIFFERENT one will be 2, and the third different will be 3.
We ignore 0s.
Col1 (unique=[3,4,1])) [3 4 1 4 0] –&gt; [1 4 3 4 0] –&gt; [1 2 3 2 0] Done!
Col2 (unique=[5,3])    [5 5 5 0 3] –&gt; [1 1 1 0 3] –&gt; [1 1 1 0 2] Done!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mon</strong> (<em>np.ndarray</em>) – Input monomial that cannot be further factorised.</p></li>
<li><p><strong>inflevels</strong> (<em>np.array</em>) – Number of copies of each source in the inflated graph.</p></li>
<li><p><strong>commuting</strong> (<em>bool</em>) – Whether all the involved operators commute or not.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Input monomial in canonical form.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.to_representative_aux">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">to_representative_aux</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">monomial_component</span><span class="p">:</span> <span class="n">numpy.ndarray</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#to_representative_aux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.to_representative_aux" title="Permalink to this definition">¶</a></dt>
<dd><p>Auxiliary function for to_representative. It applies source swaps
until we reach a stable point in terms of lexiographic ordering. This might
not be a global optimum if we also take into account the commutativity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>monomial_component</strong> (<em>np.ndarray</em>) – Input monomial.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An equivalent monomial closer to its representative form.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.general_tools.transform_vars_to_symb">
<code class="sig-prename descclassname">causalinflation.quantum.general_tools.</code><code class="sig-name descname">transform_vars_to_symb</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">variables_to_be_given</span><span class="p">:</span> <span class="n">List<span class="p">[</span>numpy.ndarray<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">max_nr_of_parties</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">2</span></em><span class="sig-paren">)</span> &#x2192; List<span class="p">[</span>numpy.ndarray<span class="p">]</span><a class="reference internal" href="_modules/causalinflation/quantum/general_tools.html#transform_vars_to_symb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.general_tools.transform_vars_to_symb" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms a list of knowable variables to a list of symbolic
probabilities. See Examples.</p>
<p>TODO: Rewrite using <cite>string2prob</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variables_to_be_given</strong> (<em>np.ndarray</em>) – A 2d array of type object</p></li>
<li><p><strong>max_nr_of_parties</strong> (<em>int</em><em>, </em><em>optional</em>) – What is the maximum number of parties. By default 2. If the number of
parties is 4, then pABCD(abcd|xyzw) gets simplified to p(abcd|xyzw).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Same format as input, but string monomials replaced with symbolic
probabilities.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[List]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">transform_vars_to_symb</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;B_1_0_1_0_0&#39;</span><span class="p">],</span>
<span class="go">                            [6, &#39;A_1_1_0_1_3*B_1_0_1_2_0&#39;]])</span>
<span class="go">[[3, pB(0|0)], [6, p(30|12)]]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-causalinflation.quantum.sdp_utils">
<span id="causalinflation-quantum-sdp-utils-module"></span><h2>causalinflation.quantum.sdp_utils module<a class="headerlink" href="#module-causalinflation.quantum.sdp_utils" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="causalinflation.quantum.sdp_utils.solveSDP_MosekFUSION">
<code class="sig-prename descclassname">causalinflation.quantum.sdp_utils.</code><code class="sig-name descname">solveSDP_MosekFUSION</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">positionsmatrix</span><span class="p">:</span> <span class="n">scipy.sparse.lil.lil_matrix</span></em>, <em class="sig-param"><span class="n">objective</span><span class="p">:</span> <span class="n">dict</span> <span class="o">=</span> <span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">known_vars</span><span class="o">=</span><span class="default_value">[0, 1]</span></em>, <em class="sig-param"><span class="n">semiknown_vars</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">positive_vars</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">0</span></em>, <em class="sig-param"><span class="n">feas_as_optim</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">solverparameters</span><span class="p">:</span> <span class="n">dict</span> <span class="o">=</span> <span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/causalinflation/quantum/sdp_utils.html#solveSDP_MosekFUSION"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.sdp_utils.solveSDP_MosekFUSION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-causalinflation.quantum.typing">
<span id="causalinflation-quantum-typing-module"></span><h2>causalinflation.quantum.typing module<a class="headerlink" href="#module-causalinflation.quantum.typing" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-causalinflation.quantum.writer_utils">
<span id="causalinflation-quantum-writer-utils-module"></span><h2>causalinflation.quantum.writer_utils module<a class="headerlink" href="#module-causalinflation.quantum.writer_utils" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="causalinflation.quantum.writer_utils.convert_to_human_readable">
<code class="sig-prename descclassname">causalinflation.quantum.writer_utils.</code><code class="sig-name descname">convert_to_human_readable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">problem</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/causalinflation/quantum/writer_utils.html#convert_to_human_readable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.writer_utils.convert_to_human_readable" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the SDP relaxation to a human-readable format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>problem</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">inflapyon.InflationSDP</span></code>.) – The SDP relaxation to write.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>tuple of the objective function in a string and a matrix of
strings as the symbolic representation of the moment matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.writer_utils.pickle_load">
<code class="sig-prename descclassname">causalinflation.quantum.writer_utils.</code><code class="sig-name descname">pickle_load</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/causalinflation/quantum/writer_utils.html#pickle_load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.writer_utils.pickle_load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.writer_utils.write_to_csv">
<code class="sig-prename descclassname">causalinflation.quantum.writer_utils.</code><code class="sig-name descname">write_to_csv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">problem</span></em>, <em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/causalinflation/quantum/writer_utils.html#write_to_csv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.writer_utils.write_to_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Export the problem in a human-readable form in a CSV table.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>problem</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">inflapyon.InflationSDP</span></code>.) – The SDP relaxation to write.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.writer_utils.write_to_mat">
<code class="sig-prename descclassname">causalinflation.quantum.writer_utils.</code><code class="sig-name descname">write_to_mat</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">problem</span></em>, <em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/causalinflation/quantum/writer_utils.html#write_to_mat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.writer_utils.write_to_mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Export the problem to MATLAB .mat file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>problem</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">inflapyon.InflationSDP</span></code>.) – The SDP relaxation to write.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="causalinflation.quantum.writer_utils.write_to_sdpa">
<code class="sig-prename descclassname">causalinflation.quantum.writer_utils.</code><code class="sig-name descname">write_to_sdpa</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">problem</span></em>, <em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/causalinflation/quantum/writer_utils.html#write_to_sdpa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#causalinflation.quantum.writer_utils.write_to_sdpa" title="Permalink to this definition">¶</a></dt>
<dd><p>Export the problem to a file in  . See specifications at
<a class="reference external" href="http://euler.nmt.edu/~brian/sdplib/FORMAT">http://euler.nmt.edu/~brian/sdplib/FORMAT</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>problem</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">inflapyon.InflationSDP</span></code>.) – The SDP relaxation to write.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-causalinflation.quantum">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-causalinflation.quantum" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="causalinflation.html" class="btn btn-neutral float-left" title="causalinflation package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Emanuel-Cristian Boghiu, Alejandro Pozas-Kerstjens.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>