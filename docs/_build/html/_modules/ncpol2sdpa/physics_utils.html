<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ncpol2sdpa.physics_utils &mdash; inflation 0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> inflation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../download.html">Download and Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bibliography.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">inflation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generatingset.html">How to customize the generating set</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">inflation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>ncpol2sdpa.physics_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ncpol2sdpa.physics_utils</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The module contains helper functions for physics applications.</span>

<span class="sd">Created on Fri May 16 14:27:47 2014</span>

<span class="sd">@author: Peter Wittek</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">S</span>
<span class="kn">from</span> <span class="nn">sympy.physics.quantum.dagger</span> <span class="kn">import</span> <span class="n">Dagger</span>
<span class="kn">from</span> <span class="nn">sympy.physics.quantum</span> <span class="kn">import</span> <span class="n">HermitianOperator</span>
<span class="kn">from</span> <span class="nn">.nc_utils</span> <span class="kn">import</span> <span class="n">generate_operators</span><span class="p">,</span> <span class="n">flatten</span>
<span class="kn">from</span> <span class="nn">.solver_common</span> <span class="kn">import</span> <span class="n">solve_sdp</span>
<span class="kn">from</span> <span class="nn">.sdp_relaxation</span> <span class="kn">import</span> <span class="n">SdpRelaxation</span>


<div class="viewcode-block" id="get_neighbors"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.physics_utils.get_neighbors">[docs]</a><span class="k">def</span> <span class="nf">get_neighbors</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">lattice_length</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the forward neighbors of a site in a lattice.</span>

<span class="sd">    :param index: Linear index of operator.</span>
<span class="sd">    :type index: int.</span>
<span class="sd">    :param lattice_length: The size of the 2D lattice in either dimension</span>
<span class="sd">    :type lattice_length: int.</span>
<span class="sd">    :param width: Optional parameter to define width.</span>
<span class="sd">    :type width: int.</span>
<span class="sd">    :param periodic: Optional parameter to indicate periodic boundary</span>
<span class="sd">                     conditions.</span>
<span class="sd">    :type periodic: bool</span>

<span class="sd">    :returns: list of int -- the neighbors in linear index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">width</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">lattice_length</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">periodic</span> <span class="ow">and</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="n">width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lattice_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="n">width</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">periodic</span><span class="p">:</span>
        <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span> <span class="o">-</span> <span class="p">(</span><span class="n">lattice_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">width</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">neighbors</span></div>


<div class="viewcode-block" id="get_next_neighbors"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.physics_utils.get_next_neighbors">[docs]</a><span class="k">def</span> <span class="nf">get_next_neighbors</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">lattice_length</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                       <span class="n">periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the forward neighbors at a given distance of a site or set of sites</span>
<span class="sd">    in a lattice.</span>

<span class="sd">    :param index: Linear index of operator.</span>
<span class="sd">    :type index: int.</span>
<span class="sd">    :param lattice_length: The size of the 2D lattice in either dimension</span>
<span class="sd">    :type lattice_length: int.</span>
<span class="sd">    :param width: Optional parameter to define width.</span>
<span class="sd">    :type width: int.</span>
<span class="sd">    :param distance: Optional parameter to define distance.</span>
<span class="sd">    :type width: int.</span>
<span class="sd">    :param periodic: Optional parameter to indicate periodic boundary</span>
<span class="sd">                     conditions.</span>
<span class="sd">    :type periodic: bool</span>

<span class="sd">    :returns: list of int -- the neighbors at given distance in linear index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">distance</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flatten</span><span class="p">(</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">lattice_length</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">periodic</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">get_next_neighbors</span><span class="p">(</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">index</span><span class="p">,</span>
                                                          <span class="n">lattice_length</span><span class="p">,</span>
                                                          <span class="n">width</span><span class="p">,</span> <span class="n">periodic</span><span class="p">),</span>
                                            <span class="n">lattice_length</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">distance</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                            <span class="n">periodic</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">))</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">get_next_neighbors</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">lattice_length</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">distance</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">periodic</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">s1</span> <span class="o">-</span> <span class="n">s2</span><span class="p">)</span></div>


<div class="viewcode-block" id="bosonic_constraints"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.physics_utils.bosonic_constraints">[docs]</a><span class="k">def</span> <span class="nf">bosonic_constraints</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return  a set of constraints that define fermionic ladder operators.</span>

<span class="sd">    :param a: The non-Hermitian variables.</span>
<span class="sd">    :type a: list of :class:`sympy.physics.quantum.operator.Operator`.</span>
<span class="sd">    :returns: a dict of substitutions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ai</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">substitutions</span><span class="p">[</span><span class="n">ai</span> <span class="o">*</span> <span class="n">Dagger</span><span class="p">(</span><span class="n">ai</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">Dagger</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span> <span class="o">*</span> <span class="n">ai</span>
        <span class="k">for</span> <span class="n">aj</span> <span class="ow">in</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="c1"># substitutions[ai*Dagger(aj)] = -Dagger(ai)*aj</span>
            <span class="n">substitutions</span><span class="p">[</span><span class="n">ai</span><span class="o">*</span><span class="n">Dagger</span><span class="p">(</span><span class="n">aj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Dagger</span><span class="p">(</span><span class="n">aj</span><span class="p">)</span><span class="o">*</span><span class="n">ai</span>
            <span class="n">substitutions</span><span class="p">[</span><span class="n">Dagger</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span><span class="o">*</span><span class="n">aj</span><span class="p">]</span> <span class="o">=</span> <span class="n">aj</span><span class="o">*</span><span class="n">Dagger</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
            <span class="n">substitutions</span><span class="p">[</span><span class="n">ai</span><span class="o">*</span><span class="n">aj</span><span class="p">]</span> <span class="o">=</span> <span class="n">aj</span><span class="o">*</span><span class="n">ai</span>
            <span class="n">substitutions</span><span class="p">[</span><span class="n">Dagger</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span> <span class="o">*</span> <span class="n">Dagger</span><span class="p">(</span><span class="n">aj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Dagger</span><span class="p">(</span><span class="n">aj</span><span class="p">)</span> <span class="o">*</span> <span class="n">Dagger</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">substitutions</span></div>


<div class="viewcode-block" id="fermionic_constraints"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.physics_utils.fermionic_constraints">[docs]</a><span class="k">def</span> <span class="nf">fermionic_constraints</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return  a set of constraints that define fermionic ladder operators.</span>

<span class="sd">    :param a: The non-Hermitian variables.</span>
<span class="sd">    :type a: list of :class:`sympy.physics.quantum.operator.Operator`.</span>
<span class="sd">    :returns: a dict of substitutions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ai</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">substitutions</span><span class="p">[</span><span class="n">ai</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">substitutions</span><span class="p">[</span><span class="n">Dagger</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">substitutions</span><span class="p">[</span><span class="n">ai</span> <span class="o">*</span> <span class="n">Dagger</span><span class="p">(</span><span class="n">ai</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">Dagger</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span> <span class="o">*</span> <span class="n">ai</span>
        <span class="k">for</span> <span class="n">aj</span> <span class="ow">in</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="c1"># substitutions[ai*Dagger(aj)] = -Dagger(ai)*aj</span>
            <span class="n">substitutions</span><span class="p">[</span><span class="n">ai</span><span class="o">*</span><span class="n">Dagger</span><span class="p">(</span><span class="n">aj</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Dagger</span><span class="p">(</span><span class="n">aj</span><span class="p">)</span><span class="o">*</span><span class="n">ai</span>
            <span class="n">substitutions</span><span class="p">[</span><span class="n">Dagger</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span><span class="o">*</span><span class="n">aj</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">aj</span><span class="o">*</span><span class="n">Dagger</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
            <span class="n">substitutions</span><span class="p">[</span><span class="n">ai</span><span class="o">*</span><span class="n">aj</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">aj</span><span class="o">*</span><span class="n">ai</span>
            <span class="n">substitutions</span><span class="p">[</span><span class="n">Dagger</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span> <span class="o">*</span> <span class="n">Dagger</span><span class="p">(</span><span class="n">aj</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">Dagger</span><span class="p">(</span><span class="n">aj</span><span class="p">)</span> <span class="o">*</span> <span class="n">Dagger</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">substitutions</span></div>


<div class="viewcode-block" id="pauli_constraints"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.physics_utils.pauli_constraints">[docs]</a><span class="k">def</span> <span class="nf">pauli_constraints</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return  a set of constraints that define Pauli spin operators.</span>

<span class="sd">    :param X: List of Pauli X operator on sites.</span>
<span class="sd">    :type X: list of :class:`sympy.physics.quantum.operator.HermitianOperator`.</span>
<span class="sd">    :param Y: List of Pauli Y operator on sites.</span>
<span class="sd">    :type Y: list of :class:`sympy.physics.quantum.operator.HermitianOperator`.</span>
<span class="sd">    :param Z: List of Pauli Z operator on sites.</span>
<span class="sd">    :type Z: list of :class:`sympy.physics.quantum.operator.HermitianOperator`.</span>

<span class="sd">    :returns: tuple of substitutions and equalities.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">n_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vars</span><span class="p">):</span>
        <span class="c1"># They square to the identity</span>
        <span class="n">substitutions</span><span class="p">[</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">substitutions</span><span class="p">[</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">substitutions</span><span class="p">[</span><span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Anticommutation relations</span>
        <span class="n">substitutions</span><span class="p">[</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">substitutions</span><span class="p">[</span><span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">substitutions</span><span class="p">[</span><span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># Commutation relations.</span>
        <span class="c1"># equalities.append(X[i]*Y[i] - 1j*Z[i])</span>
        <span class="c1"># equalities.append(X[i]*Z[i] + 1j*Y[i])</span>
        <span class="c1"># equalities.append(Y[i]*Z[i] - 1j*X[i])</span>
        <span class="c1"># They commute between the sites</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">):</span>
            <span class="n">substitutions</span><span class="p">[</span><span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">substitutions</span><span class="p">[</span><span class="n">Y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">substitutions</span><span class="p">[</span><span class="n">Y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">substitutions</span><span class="p">[</span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">substitutions</span><span class="p">[</span><span class="n">Z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">substitutions</span><span class="p">[</span><span class="n">Z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">substitutions</span><span class="p">[</span><span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">substitutions</span><span class="p">[</span><span class="n">Z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">substitutions</span><span class="p">[</span><span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Y</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">substitutions</span></div>

<div class="viewcode-block" id="generate_operators"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.physics_utils.generate_operators">[docs]</a><span class="k">def</span> <span class="nf">generate_operators</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n_vars</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hermitian</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">commutative</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates a number of commutative or noncommutative operators</span>

<span class="sd">    :param name: The prefix in the symbolic representation of the noncommuting</span>
<span class="sd">                 variables. This will be suffixed by a number from 0 to</span>
<span class="sd">                 n_vars-1 if n_vars &gt; 1.</span>
<span class="sd">    :type name: str.</span>
<span class="sd">    :param n_vars: The number of variables.</span>
<span class="sd">    :type n_vars: int.</span>
<span class="sd">    :param hermitian: Optional parameter to request Hermitian variables .</span>
<span class="sd">    :type hermitian: bool.</span>
<span class="sd">    :param commutative: Optional parameter to request commutative variables.</span>
<span class="sd">                        Commutative variables are Hermitian by default.</span>
<span class="sd">    :type commutative: bool.</span>

<span class="sd">    :returns: list of :class:`sympy.physics.quantum.operator.Operator` or</span>
<span class="sd">              :class:`sympy.physics.quantum.operator.HermitianOperator`</span>
<span class="sd">              variables</span>

<span class="sd">    :Example:</span>

<span class="sd">    &gt;&gt;&gt; generate_variables(&#39;y&#39;, 2, commutative=True)</span>
<span class="sd">    ï¿¼[y0, y1]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vars</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n_vars</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">var_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">hermitian</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">hermitian</span><span class="p">:</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">HermitianOperator</span><span class="p">(</span><span class="n">var_name</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Operator</span><span class="p">(</span><span class="n">var_name</span><span class="p">))</span>
        <span class="n">variables</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_commutative</span> <span class="o">=</span> <span class="n">commutative</span>
    <span class="k">return</span> <span class="n">variables</span></div>

<div class="viewcode-block" id="generate_measurements"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.physics_utils.generate_measurements">[docs]</a><span class="k">def</span> <span class="nf">generate_measurements</span><span class="p">(</span><span class="n">party</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate variables that behave like measurements.</span>

<span class="sd">    :param party: The list of number of measurement outputs a party has.</span>
<span class="sd">    :type party: list of int.</span>
<span class="sd">    :param label: The label to be given to the symbolic variables.</span>
<span class="sd">    :type label: str.</span>

<span class="sd">    :returns: list of list of</span>
<span class="sd">             :class:`sympy.physics.quantum.operator.HermitianOperator`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">measurements</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">party</span><span class="p">)):</span>
        <span class="n">measurements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">generate_operators</span><span class="p">(</span><span class="n">label</span> <span class="o">+</span> <span class="s1">&#39;_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">party</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                               <span class="n">hermitian</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">measurements</span></div>


<div class="viewcode-block" id="projective_measurement_constraints"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.physics_utils.projective_measurement_constraints">[docs]</a><span class="k">def</span> <span class="nf">projective_measurement_constraints</span><span class="p">(</span><span class="o">*</span><span class="n">parties</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a set of constraints that define projective measurements.</span>

<span class="sd">    :param parties: Measurements of different parties.</span>
<span class="sd">    :type A: list or tuple of list of list of</span>
<span class="sd">             :class:`sympy.physics.quantum.operator.HermitianOperator`.</span>

<span class="sd">    :returns: substitutions containing idempotency, orthogonality and</span>
<span class="sd">              commutation relations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Idempotency and orthogonality of projectors</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parties</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">parties</span> <span class="o">=</span> <span class="n">parties</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">party</span> <span class="ow">in</span> <span class="n">parties</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">measurement</span> <span class="ow">in</span> <span class="n">party</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">projector1</span> <span class="ow">in</span> <span class="n">measurement</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">projector2</span> <span class="ow">in</span> <span class="n">measurement</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">projector1</span> <span class="o">==</span> <span class="n">projector2</span><span class="p">:</span>
                        <span class="n">substitutions</span><span class="p">[</span><span class="n">projector1</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">projector1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">substitutions</span><span class="p">[</span><span class="n">projector1</span><span class="o">*</span><span class="n">projector2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">substitutions</span><span class="p">[</span><span class="n">projector2</span><span class="o">*</span><span class="n">projector1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Projectors commute between parties in a partition</span>
    <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parties</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">parties</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">measurement1</span> <span class="ow">in</span> <span class="n">parties</span><span class="p">[</span><span class="n">n1</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">measurement2</span> <span class="ow">in</span> <span class="n">parties</span><span class="p">[</span><span class="n">n2</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">projector1</span> <span class="ow">in</span> <span class="n">measurement1</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">projector2</span> <span class="ow">in</span> <span class="n">measurement2</span><span class="p">:</span>
                            <span class="n">substitutions</span><span class="p">[</span><span class="n">projector2</span><span class="o">*</span><span class="n">projector1</span><span class="p">]</span> <span class="o">=</span> \
                                <span class="n">projector1</span><span class="o">*</span><span class="n">projector2</span>
    <span class="k">return</span> <span class="n">substitutions</span></div>


<div class="viewcode-block" id="define_objective_with_I"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.physics_utils.define_objective_with_I">[docs]</a><span class="k">def</span> <span class="nf">define_objective_with_I</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define a polynomial using measurements and an I matrix describing a Bell</span>
<span class="sd">    inequality.</span>

<span class="sd">    :param I: The I matrix of a Bell inequality in the Collins-Gisin notation.</span>
<span class="sd">    :type I: list of list of int.</span>
<span class="sd">    :param args: Either the measurements of Alice and Bob or a `Probability`</span>
<span class="sd">                 class describing their measurement operators.</span>
<span class="sd">    :type A: tuple of list of list of</span>
<span class="sd">             :class:`sympy.physics.quantum.operator.HermitianOperator` or</span>
<span class="sd">             :class:`ncpol2sdpa.Probability`</span>

<span class="sd">    :returns: :class:`sympy.core.expr.Expr` -- the objective function to be</span>
<span class="sd">              solved as a minimization problem to find the maximum quantum</span>
<span class="sd">              violation. Note that the sign is flipped compared to the Bell</span>
<span class="sd">              inequality.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">objective</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Wrong number of arguments!&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parties</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parties</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>  <span class="c1"># Row and column index in I</span>
    <span class="k">for</span> <span class="n">m_Bj</span> <span class="ow">in</span> <span class="n">B</span><span class="p">:</span>  <span class="c1"># Define first row</span>
        <span class="k">for</span> <span class="n">Bj</span> <span class="ow">in</span> <span class="n">m_Bj</span><span class="p">:</span>
            <span class="n">objective</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">Bj</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">m_Ai</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">Ai</span> <span class="ow">in</span> <span class="n">m_Ai</span><span class="p">:</span>
            <span class="n">objective</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Ai</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">m_Bj</span> <span class="ow">in</span> <span class="n">B</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">Bj</span> <span class="ow">in</span> <span class="n">m_Bj</span><span class="p">:</span>
                    <span class="n">objective</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">Ai</span> <span class="o">*</span> <span class="n">Bj</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">objective</span></div>


<div class="viewcode-block" id="correlator"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.physics_utils.correlator">[docs]</a><span class="k">def</span> <span class="nf">correlator</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Correlators between the probabilities of two parties.</span>

<span class="sd">    :param A: Measurements of Alice.</span>
<span class="sd">    :type A: list of list of</span>
<span class="sd">             :class:`sympy.physics.quantum.operator.HermitianOperator`.</span>
<span class="sd">    :param B: Measurements of Bob.</span>
<span class="sd">    :type B: list of list of</span>
<span class="sd">             :class:`sympy.physics.quantum.operator.HermitianOperator`.</span>

<span class="sd">    :returns: list of correlators.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">correlators</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
        <span class="n">correlator_row</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)):</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">])):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">l</span><span class="p">:</span>
                        <span class="n">corr</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">l</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">corr</span> <span class="o">-=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">l</span><span class="p">]</span>
            <span class="n">correlator_row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span>
        <span class="n">correlators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">correlator_row</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">correlators</span></div>


<div class="viewcode-block" id="maximum_violation"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.physics_utils.maximum_violation">[docs]</a><span class="k">def</span> <span class="nf">maximum_violation</span><span class="p">(</span><span class="n">A_configuration</span><span class="p">,</span> <span class="n">B_configuration</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the maximum violation of a two-party Bell inequality.</span>

<span class="sd">    :param A_configuration: Measurement settings of Alice.</span>
<span class="sd">    :type A_configuration: list of int.</span>
<span class="sd">    :param B_configuration: Measurement settings of Bob.</span>
<span class="sd">    :type B_configuration: list of int.</span>
<span class="sd">    :param I: The I matrix of a Bell inequality in the Collins-Gisin notation.</span>
<span class="sd">    :type I: list of list of int.</span>
<span class="sd">    :param level: Level of relaxation.</span>
<span class="sd">    :type level: int.</span>

<span class="sd">    :returns: tuple of primal and dual solutions of the SDP relaxation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">Probability</span><span class="p">(</span><span class="n">A_configuration</span><span class="p">,</span> <span class="n">B_configuration</span><span class="p">)</span>
    <span class="n">objective</span> <span class="o">=</span> <span class="n">define_objective_with_I</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">extra</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">extramonomials</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extramonomials</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">get_extra_monomials</span><span class="p">(</span><span class="n">extra</span><span class="p">)</span>
    <span class="n">sdpRelaxation</span> <span class="o">=</span> <span class="n">SdpRelaxation</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">get_all_operators</span><span class="p">(),</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">sdpRelaxation</span><span class="o">.</span><span class="n">get_relaxation</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">objective</span><span class="o">=</span><span class="n">objective</span><span class="p">,</span>
                                 <span class="n">substitutions</span><span class="o">=</span><span class="n">P</span><span class="o">.</span><span class="n">substitutions</span><span class="p">,</span>
                                 <span class="n">extramonomials</span><span class="o">=</span><span class="n">extramonomials</span><span class="p">)</span>
    <span class="n">solve_sdp</span><span class="p">(</span><span class="n">sdpRelaxation</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sdpRelaxation</span><span class="o">.</span><span class="n">primal</span><span class="p">,</span> <span class="n">sdpRelaxation</span><span class="o">.</span><span class="n">dual</span></div>


<div class="viewcode-block" id="Probability"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.physics_utils.Probability">[docs]</a><span class="k">class</span> <span class="nc">Probability</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class for working with quantum probabilities.</span>

<span class="sd">        :param *args: Input configurations for each parties</span>
<span class="sd">        :type *args: tuple of list of lists</span>
<span class="sd">        :param labels: Optional parameter string to define the label of each</span>
<span class="sd">                       party.</span>
<span class="sd">        :type labels: list of str.</span>
<span class="sd">        :Example:</span>

<span class="sd">        For a CHSH scenario, instantiate the class as</span>

<span class="sd">            P = Probability([2, 2], [2, 2])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_parties</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parties</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_parties</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;labels&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_parties</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Incorrect number of labels!&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown parameter &quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">configuration</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parties</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">generate_measurements</span><span class="p">(</span><span class="n">configuration</span><span class="p">,</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">substitutions</span> <span class="o">=</span> <span class="n">projective_measurement_constraints</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parties</span><span class="p">)</span>

<div class="viewcode-block" id="Probability.get_all_operators"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.physics_utils.Probability.get_all_operators">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_operators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all operators across all parties and measurements to supply</span>
<span class="sd">        them to the `ncpol2sdpa.SdpRelaxation` class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">flatten</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parties</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_monomial_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monomials</span><span class="p">,</span> <span class="n">label_indices</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">label_indices</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="n">monomials</span>
        <span class="k">elif</span> <span class="n">monomials</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_monomial_generator</span><span class="p">(</span>
                <span class="n">flatten</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parties</span><span class="p">[</span><span class="n">label_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">label_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">m1</span><span class="o">*</span><span class="n">m2</span> <span class="k">for</span> <span class="n">m1</span> <span class="ow">in</span> <span class="n">monomials</span>
                      <span class="k">for</span> <span class="n">m2</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parties</span><span class="p">[</span><span class="n">label_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]])]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_monomial_generator</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">label_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

<div class="viewcode-block" id="Probability.get_extra_monomials"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.physics_utils.Probability.get_extra_monomials">[docs]</a>    <span class="k">def</span> <span class="nf">get_extra_monomials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">extra_monomials</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">label_indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">party</span><span class="p">)</span> <span class="k">for</span> <span class="n">party</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>
            <span class="n">extra_monomials</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_monomial_generator</span><span class="p">([],</span> <span class="n">label_indices</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">extra_monomials</span></div>

    <span class="k">def</span> <span class="nf">_convert_marginal_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">marginal</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">marginal</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">marginal</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">m</span>
                           <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">marginal</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_</span><span class="p">,</span> <span class="n">input_</span><span class="p">,</span> <span class="n">marginal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Obtain your probabilities in the p(ab...|xy...) notation.</span>

<span class="sd">        :param output_: Conditional output as [a, b, ...]</span>
<span class="sd">        :type output_: list of ints.</span>
<span class="sd">        :param input_: The input to condition on as [x, y, ...]</span>
<span class="sd">        :type input_: list of ints.</span>
<span class="sd">        :param marginal: Optional parameter. If it is a marginal, then you can</span>
<span class="sd">                         define which party or parties it belongs to.</span>
<span class="sd">        :type marginal: list of str.</span>
<span class="sd">        :returns: polynomial of `sympy.physics.quantum.HermitianOperator`.</span>

<span class="sd">        :Example:</span>

<span class="sd">        For the CHSH scenario, to get p(10|01), write</span>

<span class="sd">            P([1,0], [0,1])</span>

<span class="sd">        To get the marginal p_A(0|1), write</span>

<span class="sd">            P([0], [1], [&#39;A&#39;])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The number of inputs does not match the number of&quot;</span>
                            <span class="s2">&quot;outputs!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_parties</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The number of inputs exceeds the number of &quot;</span>
                            <span class="s2">&quot;parties!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">marginal</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_parties</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Marginal requested, but without defining which!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">marginal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">marginal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_marginal_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">marginal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_marginal_index</span><span class="p">(</span><span class="n">marginal</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">marginal</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The number of parties in the marginal does &quot;</span>
                                <span class="s2">&quot;not match the number of inputs!&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">for</span> <span class="n">party</span><span class="p">,</span> <span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">meas</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">output_</span><span class="p">,</span> <span class="n">input_</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parties</span><span class="p">[</span><span class="n">marginal</span><span class="p">[</span><span class="n">party</span><span class="p">]])</span> <span class="o">&lt;</span> <span class="n">meas</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Invalid measurement index &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">meas</span><span class="p">)</span> <span class="o">+</span>
                                <span class="s2">&quot; for party &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">party</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parties</span><span class="p">[</span><span class="n">marginal</span><span class="p">[</span><span class="n">party</span><span class="p">]][</span><span class="n">meas</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">proj</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Invalid projection operator index &quot;</span> <span class="o">+</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; for party &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">party</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parties</span><span class="p">[</span><span class="n">marginal</span><span class="p">[</span><span class="n">party</span><span class="p">]][</span><span class="n">meas</span><span class="p">])</span> <span class="o">==</span> <span class="n">proj</span><span class="p">:</span>
                <span class="c1"># We are in the Collins-Gisin picture: the last projector</span>
                <span class="c1"># is not part of the measurement.</span>
                <span class="n">result</span> <span class="o">*=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span> <span class="o">-</span> \
                    <span class="nb">sum</span><span class="p">(</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parties</span><span class="p">[</span><span class="n">marginal</span><span class="p">[</span><span class="n">party</span><span class="p">]][</span><span class="n">meas</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parties</span><span class="p">[</span><span class="n">marginal</span><span class="p">[</span><span class="n">party</span><span class="p">]][</span><span class="n">meas</span><span class="p">][</span><span class="n">proj</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Emanuel-Cristian Boghiu, Alejandro Pozas-Kerstjens.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>