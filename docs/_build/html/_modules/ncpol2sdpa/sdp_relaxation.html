<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ncpol2sdpa.sdp_relaxation &mdash; inflation 0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> inflation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../download.html">Download and Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bibliography.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">inflation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generatingset.html">How to customize the generating set</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">inflation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>ncpol2sdpa.sdp_relaxation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ncpol2sdpa.sdp_relaxation</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The module converts a noncommutative optimization problem provided in SymPy</span>
<span class="sd">format to an SDPA semidefinite programming problem.</span>

<span class="sd">Created on Sun May 26 15:06:17 2013</span>

<span class="sd">@author: Peter Wittek</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">lil_matrix</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">S</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">Add</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">imap</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">imap</span> <span class="o">=</span> <span class="nb">map</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">cpu_count</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">IPython.core.display</span> <span class="kn">import</span> <span class="n">clear_output</span>
    <span class="n">have_ipython</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">have_ipython</span> <span class="o">=</span> <span class="kc">False</span>

<span class="kn">from</span> <span class="nn">.nc_utils</span> <span class="kn">import</span> <span class="n">apply_substitutions</span><span class="p">,</span> \
    <span class="n">assemble_monomial_and_do_substitutions</span><span class="p">,</span> <span class="n">convert_relational</span><span class="p">,</span> \
    <span class="n">find_variable_set</span><span class="p">,</span> <span class="n">flatten</span><span class="p">,</span> <span class="n">flip_sign</span><span class="p">,</span> <span class="n">get_all_monomials</span><span class="p">,</span> <span class="n">is_number_type</span><span class="p">,</span> \
    <span class="n">is_pure_substitution_rule</span><span class="p">,</span> <span class="n">iscomplex</span><span class="p">,</span> <span class="n">moment_of_entry</span><span class="p">,</span> <span class="n">ncdegree</span><span class="p">,</span> \
    <span class="n">pick_monomials_up_to_degree</span><span class="p">,</span> <span class="n">save_monomial_index</span><span class="p">,</span> <span class="n">separate_scalar_factor</span><span class="p">,</span> \
    <span class="n">simplify_polynomial</span><span class="p">,</span> <span class="n">unique</span>
<span class="kn">from</span> <span class="nn">.solver_common</span> <span class="kn">import</span> <span class="n">find_solution_ranks</span><span class="p">,</span> <span class="n">get_sos_decomposition</span><span class="p">,</span> \
    <span class="n">get_xmat_value</span><span class="p">,</span> <span class="n">solve_sdp</span><span class="p">,</span> <span class="n">extract_dual_value</span>
<span class="kn">from</span> <span class="nn">.cvxpy_utils</span> <span class="kn">import</span> <span class="n">convert_to_cvxpy</span>
<span class="kn">from</span> <span class="nn">.mosek_utils</span> <span class="kn">import</span> <span class="n">convert_to_mosek</span>
<span class="kn">from</span> <span class="nn">.picos_utils</span> <span class="kn">import</span> <span class="n">convert_to_picos</span>
<span class="kn">from</span> <span class="nn">.sdpa_utils</span> <span class="kn">import</span> <span class="n">write_to_sdpa</span><span class="p">,</span> <span class="n">write_to_human_readable</span>
<span class="kn">from</span> <span class="nn">.chordal_extension</span> <span class="kn">import</span> <span class="n">find_variable_cliques</span>


<div class="viewcode-block" id="Relaxation"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.sdp_relaxation.Relaxation">[docs]</a><span class="k">class</span> <span class="nc">Relaxation</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor for the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_facvar</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constant_term</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Variables related to the solution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">primal</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_mat</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_mat</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solution_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;unsolved&quot;</span>

<div class="viewcode-block" id="Relaxation.solve"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.sdp_relaxation.Relaxation.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">solverparameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call a solver on the SDP relaxation. Upon successful solution, it</span>
<span class="sd">        returns the primal and dual objective values along with the solution</span>
<span class="sd">        matrices. It also sets these values in the `sdpRelaxation` object,</span>
<span class="sd">        along with some status information.</span>

<span class="sd">        :param sdpRelaxation: The SDP relaxation to be solved.</span>
<span class="sd">        :type sdpRelaxation: :class:`ncpol2sdpa.SdpRelaxation`.</span>
<span class="sd">        :param solver: The solver to be called, either `None`, &quot;sdpa&quot;, &quot;mosek&quot;,</span>
<span class="sd">                       &quot;cvxpy&quot;, &quot;scs&quot;, or &quot;cvxopt&quot;. The default is `None`,</span>
<span class="sd">                       which triggers autodetect.</span>
<span class="sd">        :type solver: str.</span>
<span class="sd">        :param solverparameters: Parameters to be passed to the solver. Actual</span>
<span class="sd">                                 options depend on the solver:</span>

<span class="sd">                                 SDPA:</span>

<span class="sd">                                   - `&quot;executable&quot;`:</span>
<span class="sd">                                     Specify the executable for SDPA. E.g.,</span>
<span class="sd">                                     `&quot;executable&quot;:&quot;/usr/local/bin/sdpa&quot;`, or</span>
<span class="sd">                                     `&quot;executable&quot;:&quot;sdpa_gmp&quot;`</span>
<span class="sd">                                   - `&quot;paramsfile&quot;`: Specify the parameter file</span>

<span class="sd">                                 Mosek:</span>
<span class="sd">                                 Refer to the Mosek documentation. All</span>
<span class="sd">                                 arguments are passed on.</span>

<span class="sd">                                 Cvxopt:</span>
<span class="sd">                                 Refer to the PICOS documentation. All</span>
<span class="sd">                                 arguments are passed on.</span>

<span class="sd">                                 Cvxpy:</span>
<span class="sd">                                 Refer to the Cvxpy documentation. All</span>
<span class="sd">                                 arguments are passed on.</span>

<span class="sd">                                 SCS:</span>
<span class="sd">                                 Refer to the Cvxpy documentation. All</span>
<span class="sd">                                 arguments are passed on.</span>

<span class="sd">        :type solverparameters: dict of str.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Relaxation is not generated yet. Call &quot;</span>
                            <span class="s2">&quot;&#39;SdpRelaxation.get_relaxation&#39; first&quot;</span><span class="p">)</span>
        <span class="n">solve_sdp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">,</span> <span class="n">solverparameters</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SdpRelaxation"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.sdp_relaxation.SdpRelaxation">[docs]</a><span class="k">class</span> <span class="nc">SdpRelaxation</span><span class="p">(</span><span class="n">Relaxation</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Class for obtaining sparse SDP relaxation.</span>

<span class="sd">    :param variables: Commutative or noncommutative, Hermitian or nonhermiatian</span>
<span class="sd">                      variables, possibly a list of list of variables if the</span>
<span class="sd">                      hierarchy is not NPA.</span>
<span class="sd">    :type variables: list of :class:`sympy.physics.quantum.operator.Operator`</span>
<span class="sd">                     or</span>
<span class="sd">                     :class:`sympy.physics.quantum.operator.HermitianOperator`</span>
<span class="sd">                     or a list of list.</span>
<span class="sd">    :param parameters: Optional symbolic variables for which moments are not</span>
<span class="sd">                       generated.</span>
<span class="sd">    :type parameters: list of :class:`sympy.physics.quantum.operator.Operator`</span>
<span class="sd">                     or</span>
<span class="sd">                     :class:`sympy.physics.quantum.operator.HermitianOperator`</span>
<span class="sd">                     or a list of list.</span>
<span class="sd">    :param verbose: Optional parameter for level of verbosity:</span>

<span class="sd">                       * 0: quiet (default)</span>
<span class="sd">                       * 1: verbose</span>
<span class="sd">                       * 2: debug level</span>
<span class="sd">    :type verbose: int.</span>
<span class="sd">    :param normalized: Optional parameter for changing the normalization of</span>
<span class="sd">                       states over which the optimization happens. Turn it off</span>
<span class="sd">                       if further processing is done on the SDP matrix before</span>
<span class="sd">                       solving it.</span>
<span class="sd">    :type normalized: bool.</span>
<span class="sd">    :param parallel: Optional parameter for allowing parallel computations.</span>
<span class="sd">    :type parallel: bool.</span>

<span class="sd">    Attributes:</span>
<span class="sd">      - `monomial_sets`: The monomial sets that generate the moment matrix blocks.</span>

<span class="sd">      - `monomial_index`: Dictionary that maps monomials to SDP variables.</span>

<span class="sd">      - `constraints`: The complete set of constraints after preprocesssing.</span>

<span class="sd">      - `primal`: The primal optimal value.</span>

<span class="sd">      - `dual`: The dual optimal value.</span>

<span class="sd">      - `x_mat`: The primal solution matrix.</span>

<span class="sd">      - `y_mat`: The dual solution matrix.</span>

<span class="sd">      - `solution_time`: The amount of time taken to solve the relaxation.</span>

<span class="sd">      - `status`: The solution status of the relaxation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">parallel</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor for the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SdpRelaxation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="c1"># Dictionary that maps monomials to SDP variables.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">monomial_index</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Variables related to generating the moment matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_offsets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span> <span class="o">=</span> <span class="n">normalized</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">substitutions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pure_substitution_rules</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">monomial_sets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moment_substitutions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">complex_matrix</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Variables related to processing constraints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">localizing_monomial_sets</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraint_starting_block</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constraint_to_block_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_moment_equalities</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_inequalities</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Variables related to basis transformation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_F</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_obj_facvar</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_constant_term</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_new_basis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time0</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">n_noncommutative_hermitian</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_noncommutative_nonhermitian</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_commutative_hermitian</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n_commutative_nonhermitian</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span>
                                       <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">unique</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span> <span class="k">for</span> <span class="n">vs</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">variables</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">vs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vs</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">vs</span> <span class="o">=</span> <span class="p">[</span><span class="n">vs</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">is_commutative</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">is_hermitian</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                                         <span class="n">v</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">):</span>
                    <span class="n">n_commutative_hermitian</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
                    <span class="n">n_commutative_nonhermitian</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">is_commutative</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">is_hermitian</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                                               <span class="n">v</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">):</span>
                    <span class="n">n_noncommutative_hermitian</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">n_noncommutative_nonhermitian</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span>
        <span class="n">info</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n_commutative_hermitian</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_commutative_hermitian</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; commuting&quot;</span>
        <span class="k">if</span> <span class="n">n_commutative_nonhermitian</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span>
            <span class="n">info</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_commutative_nonhermitian</span><span class="p">)</span> <span class="o">+</span> \
                <span class="s2">&quot; commuting nonhermitian&quot;</span>
        <span class="k">if</span> <span class="n">n_noncommutative_hermitian</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span>
            <span class="n">info</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_noncommutative_hermitian</span><span class="p">)</span> <span class="o">+</span> \
                <span class="s2">&quot; noncommuting Hermitian&quot;</span>
        <span class="k">if</span> <span class="n">n_noncommutative_nonhermitian</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span>
            <span class="n">info</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_noncommutative_nonhermitian</span><span class="p">)</span> <span class="o">+</span> \
                <span class="s2">&quot; noncommuting nonhermitian&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot; variables&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;0 variables&quot;</span>
        <span class="n">info</span> <span class="o">=</span> <span class="s2">&quot;The problem has &quot;</span> <span class="o">+</span> <span class="n">info</span>
        <span class="k">if</span> <span class="n">parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;, and &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">parameters</span><span class="p">)))</span> <span class="o">+</span> \
                <span class="s2">&quot;symbolic parameters&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parallel</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">n_cpu</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parallel</span> <span class="o">=</span> <span class="n">parallel</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Parallel processing on </span><span class="si">%d</span><span class="s2"> cores&quot;</span> <span class="o">%</span> <span class="n">n_cpu</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: multiprocessing cannot be imported!&quot;</span><span class="p">,</span>
                      <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>

    <span class="c1">########################################################################</span>
    <span class="c1"># ROUTINES RELATED TO GENERATING THE MOMENT MATRICES                   #</span>
    <span class="c1">########################################################################</span>

    <span class="k">def</span> <span class="nf">_process_monomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monomial</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process a single monomial when building the moment matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">processed_monomial</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">separate_scalar_factor</span><span class="p">(</span><span class="n">monomial</span><span class="p">)</span>
        <span class="c1"># Are we substituting this moment?</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">substitute</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moment_substitutions</span><span class="p">[</span><span class="n">processed_monomial</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">substitute</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">substitute</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">substitute</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="n">substitute</span><span class="o">.</span><span class="n">args</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_number_type</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
                            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">coeff</span><span class="o">*</span><span class="nb">complex</span><span class="p">(</span><span class="n">arg</span><span class="p">)))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">coeff</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="n">arg</span><span class="p">)))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">coeff</span><span class="o">*</span><span class="n">c2</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_monomial</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span>
                                                                       <span class="n">n_vars</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">coeff</span><span class="o">*</span><span class="n">substitute</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># Have we seen this monomial before?</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># If yes, then we improve sparsity by reusing the</span>
                <span class="c1"># previous variable to denote this entry in the matrix</span>
                <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomial_index</span><span class="p">[</span><span class="n">processed_monomial</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># If no, it still may be possible that we have already seen its</span>
                <span class="c1"># conjugate. If the problem is real-valued, a monomial and its</span>
                <span class="c1"># conjugate should be equal (Hermiticity becomes symmetry)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">complex_matrix</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># If we have seen the conjugate before, we just use the</span>
                    <span class="c1"># conjugate monomial instead</span>
                        <span class="n">processed_monomial_adjoint</span> <span class="o">=</span> \
                              <span class="n">apply_substitutions</span><span class="p">(</span><span class="n">processed_monomial</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(),</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">substitutions</span><span class="p">)</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomial_index</span><span class="p">[</span><span class="n">processed_monomial_adjoint</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="c1"># Otherwise we define a new entry in the associated</span>
                        <span class="c1"># array recording the monomials, and add an entry in</span>
                        <span class="c1"># the moment matrix</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="n">n_vars</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">monomial_index</span><span class="p">[</span><span class="n">processed_monomial</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">n_vars</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">monomial_index</span><span class="p">[</span><span class="n">processed_monomial</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_push_monomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monomial</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">,</span> <span class="n">row_offset</span><span class="p">,</span> <span class="n">rowA</span><span class="p">,</span> <span class="n">columnA</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span>
                       <span class="n">rowB</span><span class="p">,</span> <span class="n">columnB</span><span class="p">,</span> <span class="n">lenB</span><span class="p">,</span> <span class="n">prevent_substitutions</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">monomial</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moment_substitutions</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_push_monomial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moment_substitutions</span><span class="p">[</span><span class="n">monomial</span><span class="p">],</span> <span class="n">n_vars</span><span class="p">,</span> <span class="n">row_offset</span><span class="p">,</span>
                                       <span class="n">rowA</span><span class="p">,</span> <span class="n">columnA</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span>
                                       <span class="n">rowB</span><span class="p">,</span> <span class="n">columnB</span><span class="p">,</span> <span class="n">lenB</span><span class="p">,</span> <span class="n">prevent_substitutions</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_number_type</span><span class="p">(</span><span class="n">monomial</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rowA</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">columnA</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">rowB</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">columnB</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> \
                    <span class="n">monomial</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span><span class="p">:</span>
                    <span class="n">n_vars</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">row_offset</span> <span class="o">+</span> <span class="n">rowA</span> <span class="o">*</span> <span class="n">N</span><span class="o">*</span><span class="n">lenB</span> <span class="o">+</span> <span class="n">rowB</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span>
                           <span class="n">columnA</span> <span class="o">*</span> <span class="n">lenB</span> <span class="o">+</span> <span class="n">columnB</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">row_offset</span> <span class="o">+</span> <span class="n">rowA</span> <span class="o">*</span> <span class="n">N</span><span class="o">*</span><span class="n">lenB</span> <span class="o">+</span> <span class="n">rowB</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span>
                           <span class="n">columnA</span><span class="o">*</span><span class="n">lenB</span> <span class="o">+</span> <span class="n">columnB</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normalized</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">row_offset</span> <span class="o">+</span> <span class="n">rowA</span> <span class="o">*</span> <span class="n">N</span><span class="o">*</span><span class="n">lenB</span> <span class="o">+</span> <span class="n">rowB</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span>
                       <span class="n">columnA</span> <span class="o">*</span> <span class="n">lenB</span> <span class="o">+</span> <span class="n">columnB</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">monomial</span>
        <span class="k">elif</span> <span class="n">monomial</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">monomial</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">n_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_push_monomial</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">,</span> <span class="n">row_offset</span><span class="p">,</span>
                                             <span class="n">rowA</span><span class="p">,</span> <span class="n">columnA</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span>
                                             <span class="n">rowB</span><span class="p">,</span> <span class="n">columnB</span><span class="p">,</span> <span class="n">lenB</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">monomial</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">entries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_monomial</span><span class="p">(</span><span class="n">monomial</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
                <span class="n">k</span><span class="p">,</span> <span class="n">coeff</span> <span class="o">=</span> <span class="n">entry</span>
                <span class="c1"># We push the entry to the moment matrix</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">row_offset</span> <span class="o">+</span> <span class="n">rowA</span> <span class="o">*</span> <span class="n">N</span><span class="o">*</span><span class="n">lenB</span> <span class="o">+</span> <span class="n">rowB</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span>
                       <span class="n">columnA</span> <span class="o">*</span> <span class="n">lenB</span> <span class="o">+</span> <span class="n">columnB</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n_vars</span><span class="p">:</span>
                    <span class="n">n_vars</span> <span class="o">=</span> <span class="n">k</span>
        <span class="k">return</span> <span class="n">n_vars</span>

    <span class="k">def</span> <span class="nf">_generate_moment_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">,</span> <span class="n">block_index</span><span class="p">,</span> <span class="n">processed_entries</span><span class="p">,</span>
                                <span class="n">monomialsA</span><span class="p">,</span> <span class="n">monomialsB</span><span class="p">,</span> <span class="n">ppt</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate the moment matrix of monomials.</span>

<span class="sd">        Arguments:</span>
<span class="sd">        n_vars -- current number of variables</span>
<span class="sd">        block_index -- current block index in the SDP matrix</span>
<span class="sd">        monomials -- |W_d| set of words of length up to the relaxation level</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">row_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">block_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">block_size</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">block_index</span><span class="p">]:</span>
                <span class="n">row_offset</span> <span class="o">+=</span> <span class="n">block_size</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomialsA</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">monomialsB</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">assemble_monomial_and_do_substitutions</span><span class="p">,</span>
                       <span class="n">monomialsA</span><span class="o">=</span><span class="n">monomialsA</span><span class="p">,</span> <span class="n">monomialsB</span><span class="o">=</span><span class="n">monomialsB</span><span class="p">,</span> <span class="n">ppt</span><span class="o">=</span><span class="n">ppt</span><span class="p">,</span>
                       <span class="n">substitutions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">substitutions</span><span class="p">,</span>
                       <span class="n">pure_substitution_rules</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pure_substitution_rules</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parallel</span><span class="p">:</span>
            <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">()</span>
            <span class="c1"># This is just a guess and can be optimized</span>
            <span class="n">chunksize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">monomialsA</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomialsB</span><span class="p">)</span> <span class="o">*</span>
                                        <span class="nb">len</span><span class="p">(</span><span class="n">monomialsA</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">cpu_count</span><span class="p">()),</span>
                                <span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">rowA</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">monomialsA</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parallel</span><span class="p">:</span>
                <span class="n">iter_</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">[(</span><span class="n">rowA</span><span class="p">,</span> <span class="n">columnA</span><span class="p">,</span> <span class="n">rowB</span><span class="p">,</span> <span class="n">columnB</span><span class="p">)</span>
                                        <span class="k">for</span> <span class="n">rowB</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">monomialsB</span><span class="p">))</span>
                                        <span class="k">for</span> <span class="n">columnA</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rowA</span><span class="p">,</span>
                                                             <span class="nb">len</span><span class="p">(</span><span class="n">monomialsA</span><span class="p">))</span>
                                        <span class="k">for</span> <span class="n">columnB</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">rowA</span> <span class="o">==</span> <span class="n">columnA</span><span class="p">)</span><span class="o">*</span><span class="n">rowB</span><span class="p">,</span>
                                                             <span class="nb">len</span><span class="p">(</span><span class="n">monomialsB</span><span class="p">))],</span>
                                 <span class="n">chunksize</span><span class="p">)</span>
                <span class="n">print_criterion</span> <span class="o">=</span> <span class="n">processed_entries</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">iter_</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iter_</span> <span class="o">=</span> <span class="n">imap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">[(</span><span class="n">rowA</span><span class="p">,</span> <span class="n">columnA</span><span class="p">,</span> <span class="n">rowB</span><span class="p">,</span> <span class="n">columnB</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">columnA</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rowA</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomialsA</span><span class="p">))</span>
                                    <span class="k">for</span> <span class="n">rowB</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">monomialsB</span><span class="p">))</span>
                                    <span class="k">for</span> <span class="n">columnB</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">rowA</span> <span class="o">==</span> <span class="n">columnA</span><span class="p">)</span><span class="o">*</span><span class="n">rowB</span><span class="p">,</span>
                                                         <span class="nb">len</span><span class="p">(</span><span class="n">monomialsB</span><span class="p">))])</span>
            <span class="k">for</span> <span class="n">columnA</span><span class="p">,</span> <span class="n">rowB</span><span class="p">,</span> <span class="n">columnB</span><span class="p">,</span> <span class="n">monomial</span> <span class="ow">in</span> <span class="n">iter_</span><span class="p">:</span>
                <span class="n">processed_entries</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">n_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_push_monomial</span><span class="p">(</span><span class="n">monomial</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">,</span>
                                             <span class="n">row_offset</span><span class="p">,</span> <span class="n">rowA</span><span class="p">,</span>
                                             <span class="n">columnA</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">rowB</span><span class="p">,</span>
                                             <span class="n">columnB</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomialsB</span><span class="p">),</span>
                                             <span class="n">prevent_substitutions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parallel</span> <span class="ow">or</span>
                                         <span class="n">processed_entries</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="ow">or</span>
                                         <span class="n">processed_entries</span> <span class="o">==</span> <span class="n">print_criterion</span><span class="p">):</span>
                    <span class="n">percentage</span> <span class="o">=</span> <span class="n">processed_entries</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span>
                    <span class="n">time_used</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_time0</span>
                    <span class="n">eta</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">percentage</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_used</span> <span class="o">-</span> <span class="n">time_used</span>
                    <span class="n">hours</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">eta</span><span class="o">/</span><span class="mi">3600</span><span class="p">)</span>
                    <span class="n">minutes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">eta</span><span class="o">-</span><span class="mi">3600</span><span class="o">*</span><span class="n">hours</span><span class="p">)</span><span class="o">/</span><span class="mi">60</span><span class="p">)</span>
                    <span class="n">seconds</span> <span class="o">=</span> <span class="n">eta</span><span class="o">-</span><span class="mi">3600</span><span class="o">*</span><span class="n">hours</span><span class="o">-</span><span class="n">minutes</span><span class="o">*</span><span class="mi">60</span>

                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parallel</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;, working on block </span><span class="si">{:0}</span><span class="s2"> with </span><span class="si">{:0}</span><span class="s2"> processes with a chunksize of </span><span class="si">{:0d}</span><span class="s2">&quot;</span>\
                              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">block_index</span><span class="p">,</span> <span class="n">cpu_count</span><span class="p">(),</span>
                                      <span class="n">chunksize</span><span class="p">)</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:0}</span><span class="s2"> (done: </span><span class="si">{:.2%}</span><span class="s2">, ETA </span><span class="si">{:02d}</span><span class="s2">:</span><span class="si">{:02d}</span><span class="s2">:</span><span class="si">{:03.1f}</span><span class="s2">&quot;</span>\
                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_vars</span><span class="p">,</span> <span class="n">percentage</span><span class="p">,</span> <span class="n">hours</span><span class="p">,</span> <span class="n">minutes</span><span class="p">,</span> <span class="n">seconds</span><span class="p">)</span> <span class="o">+</span> \
                          <span class="n">msg</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\r\x1b</span><span class="s2">[KCurrent number of SDP variables: &quot;</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parallel</span><span class="p">:</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n_vars</span><span class="p">,</span> <span class="n">block_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">processed_entries</span>

    <span class="k">def</span> <span class="nf">_generate_all_moment_matrix_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">,</span> <span class="n">block_index</span><span class="p">):</span>
        <span class="n">processed_entries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">monomials</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomial_sets</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomials</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">monomials</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomials</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomials</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot generate square block from &quot;</span>
                                    <span class="s2">&quot;unequal monomial lists!&quot;</span><span class="p">)</span>
                <span class="n">n_vars</span><span class="p">,</span> <span class="n">block_index</span><span class="p">,</span> <span class="n">processed_entries</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_generate_moment_matrix</span><span class="p">(</span>
                        <span class="n">n_vars</span><span class="p">,</span>
                        <span class="n">block_index</span><span class="p">,</span>
                        <span class="n">processed_entries</span><span class="p">,</span>
                        <span class="n">monomials</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">monomials</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_vars</span><span class="p">,</span> <span class="n">block_index</span><span class="p">,</span> <span class="n">processed_entries</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_generate_moment_matrix</span><span class="p">(</span>
                        <span class="n">n_vars</span><span class="p">,</span>
                        <span class="n">block_index</span><span class="p">,</span>
                        <span class="n">processed_entries</span><span class="p">,</span>
                        <span class="n">monomials</span><span class="p">,</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">var_offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_vars</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n_vars</span><span class="p">,</span> <span class="n">block_index</span>

    <span class="c1">########################################################################</span>
    <span class="c1"># ROUTINES RELATED TO GENERATING THE LOCALIZING MATRICES AND PROCESSING#</span>
    <span class="c1"># CONSTRAINTS                                                          #</span>
    <span class="c1">########################################################################</span>

    <span class="k">def</span> <span class="nf">_get_index_of_monomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">enablesubstitution</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">daggered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index of a monomial.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">processed_element</span><span class="p">,</span> <span class="n">coeff1</span> <span class="o">=</span> <span class="n">separate_scalar_factor</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">processed_element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moment_substitutions</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_of_monomial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moment_substitutions</span><span class="p">[</span><span class="n">processed_element</span><span class="p">],</span> <span class="n">enablesubstitution</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">coeff</span><span class="o">*</span><span class="n">coeff1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">r</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">enablesubstitution</span><span class="p">:</span>
            <span class="n">processed_element</span> <span class="o">=</span> \
                <span class="n">apply_substitutions</span><span class="p">(</span><span class="n">processed_element</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">substitutions</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">pure_substitution_rules</span><span class="p">)</span>
        <span class="c1"># Given the monomial, we need its mapping L_y(w) to push it into</span>
        <span class="c1"># a corresponding constraint matrix</span>
        <span class="k">if</span> <span class="n">is_number_type</span><span class="p">(</span><span class="n">processed_element</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">coeff1</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">processed_element</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">monomials</span> <span class="o">=</span> <span class="n">processed_element</span><span class="o">.</span><span class="n">args</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">monomials</span> <span class="o">=</span> <span class="p">[</span><span class="n">processed_element</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">monomial</span> <span class="ow">in</span> <span class="n">monomials</span><span class="p">:</span>
            <span class="n">monomial</span><span class="p">,</span> <span class="n">coeff2</span> <span class="o">=</span> <span class="n">separate_scalar_factor</span><span class="p">(</span><span class="n">monomial</span><span class="p">)</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff1</span><span class="o">*</span><span class="n">coeff2</span>
            <span class="k">if</span> <span class="n">is_number_type</span><span class="p">(</span><span class="n">monomial</span><span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">coeff</span><span class="p">))</span>
                <span class="k">continue</span>
            <span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">monomial</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">monomial</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">monomial</span> <span class="o">=</span> <span class="o">-</span><span class="n">monomial</span>
                    <span class="n">coeff</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">coeff</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moment_substitutions</span><span class="p">[</span><span class="n">monomial</span><span class="p">]</span>
                <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_of_monomial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moment_substitutions</span><span class="p">[</span><span class="n">new_element</span><span class="p">],</span> <span class="n">enablesubstitution</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">coeff</span><span class="o">*</span><span class="n">coeff3</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">coeff3</span> <span class="ow">in</span> <span class="n">r</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomial_index</span><span class="p">[</span><span class="n">monomial</span><span class="p">]</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">coeff</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">daggered</span><span class="p">:</span>
                        <span class="n">dag_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_of_monomial</span><span class="p">(</span><span class="n">monomial</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(),</span>
                                                                 <span class="n">daggered</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">result</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">coeff0</span><span class="o">*</span><span class="n">coeff</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">coeff0</span> <span class="ow">in</span> <span class="n">dag_result</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;The requested monomial &quot;</span> <span class="o">+</span>
                                           <span class="nb">str</span><span class="p">(</span><span class="n">monomial</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; could not be found.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">__push_facvar_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polynomial</span><span class="p">,</span> <span class="n">block_index</span><span class="p">,</span> <span class="n">row_offset</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the sparse vector representation of a polynomial</span>
<span class="sd">        and pushes it to the F structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="p">[</span><span class="n">block_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Preprocess the polynomial for uniform handling later</span>
        <span class="c1"># DO NOT EXPAND THE POLYNOMIAL HERE!!!!!!!!!!!!!!!!!!!</span>
        <span class="c1"># The simplify_polynomial bypasses the problem.</span>
        <span class="c1"># Simplifying here will trigger a bug in SymPy related to</span>
        <span class="c1"># the powers of daggered variables.</span>
        <span class="c1"># polynomial = polynomial.expand()</span>
        <span class="k">if</span> <span class="n">is_number_type</span><span class="p">(</span><span class="n">polynomial</span><span class="p">)</span> <span class="ow">or</span> <span class="n">polynomial</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">polynomial</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="n">polynomial</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">()[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Identify its constituent monomials</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_of_monomial</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
            <span class="c1"># k identifies the mapped value of a word (monomial) w</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">coeff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">row_offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coeff</span>

    <span class="k">def</span> <span class="nf">_get_facvar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polynomial</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return dense vector representation of a polynomial. This function is</span>
<span class="sd">        nearly identical to __push_facvar_sparse, but instead of pushing</span>
<span class="sd">        sparse entries to the constraint matrices, it returns a dense</span>
<span class="sd">        vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">facvar</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Preprocess the polynomial for uniform handling later</span>
        <span class="k">if</span> <span class="n">is_number_type</span><span class="p">(</span><span class="n">polynomial</span><span class="p">):</span>
            <span class="n">facvar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">polynomial</span>
            <span class="k">return</span> <span class="n">facvar</span>
        <span class="n">polynomial</span> <span class="o">=</span> <span class="n">polynomial</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">polynomial</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">polynomial</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="n">polynomial</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">()[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">as_coeff_add</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_of_monomial</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="n">facvar</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coeff</span>
        <span class="k">return</span> <span class="n">facvar</span>

    <span class="k">def</span> <span class="nf">__process_inequalities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate localizing matrices</span>

<span class="sd">        Arguments:</span>
<span class="sd">        inequalities -- list of inequality constraints</span>
<span class="sd">        monomials    -- localizing monomials</span>
<span class="sd">        block_index -- the current block index in constraint matrices of the</span>
<span class="sd">                       SDP relaxation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">initial_block_index</span> <span class="o">=</span> <span class="n">block_index</span>
        <span class="n">row_offsets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">block_size</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="p">):</span>
            <span class="n">row_offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_offsets</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">+</span> <span class="n">block_size</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parallel</span><span class="p">:</span>
            <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ineq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">):</span>
            <span class="n">block_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">monomials</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">localizing_monomial_sets</span><span class="p">[</span><span class="n">block_index</span> <span class="o">-</span>
                                                      <span class="n">initial_block_index</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">lm</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomials</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ineq</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__parse_expression</span><span class="p">(</span><span class="n">ineq</span><span class="p">,</span> <span class="n">row_offsets</span><span class="p">[</span><span class="n">block_index</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">ineq</span><span class="o">.</span><span class="n">is_Relational</span><span class="p">:</span>
                <span class="n">ineq</span> <span class="o">=</span> <span class="n">convert_relational</span><span class="p">(</span><span class="n">ineq</span><span class="p">)</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">moment_of_entry</span><span class="p">,</span> <span class="n">monomials</span><span class="o">=</span><span class="n">monomials</span><span class="p">,</span> <span class="n">ineq</span><span class="o">=</span><span class="n">ineq</span><span class="p">,</span>
                           <span class="n">substitutions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">substitutions</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parallel</span> <span class="ow">and</span> <span class="n">lm</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">chunksize</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lm</span><span class="o">*</span><span class="n">lm</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span>
                                    <span class="n">cpu_count</span><span class="p">()),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">iter_</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">([</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lm</span><span class="p">)</span>
                                        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">lm</span><span class="p">)),</span>
                                 <span class="n">chunksize</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iter_</span> <span class="o">=</span> <span class="n">imap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">([</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lm</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">lm</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">block_index</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraint_starting_block</span> <span class="o">+</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_n_inequalities</span> <span class="ow">and</span> <span class="n">lm</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">is_equality</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_equality</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">polynomial</span> <span class="ow">in</span> <span class="n">iter_</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_equality</span><span class="p">:</span>
                    <span class="n">row</span><span class="p">,</span> <span class="n">column</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__push_facvar_sparse</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="n">block_index</span><span class="p">,</span>
                                          <span class="n">row_offsets</span><span class="p">[</span><span class="n">block_index</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                          <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_equality</span><span class="p">:</span>
                    <span class="n">block_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">is_equality</span><span class="p">:</span>
                <span class="n">block_index</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r\x1b</span><span class="s2">[KProcessing </span><span class="si">%d</span><span class="s2">/</span><span class="si">%d</span><span class="s2"> constraints...&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">)))</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parallel</span><span class="p">:</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">block_index</span>

    <span class="k">def</span> <span class="nf">__process_equalities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">equalities</span><span class="p">,</span> <span class="n">momentequalities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate localizing matrices</span>

<span class="sd">        Arguments:</span>
<span class="sd">        equalities -- list of equality constraints</span>
<span class="sd">        equalities -- list of moment equality constraints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">monomial_sets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n_rows</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">le</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">equalities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">equality</span> <span class="ow">in</span> <span class="n">equalities</span><span class="p">:</span>
                <span class="n">le</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># Find the order of the localizing matrix</span>
                <span class="k">if</span> <span class="n">equality</span><span class="o">.</span><span class="n">is_Relational</span><span class="p">:</span>
                    <span class="n">equality</span> <span class="o">=</span> <span class="n">convert_relational</span><span class="p">(</span><span class="n">equality</span><span class="p">)</span>
                <span class="n">eq_order</span> <span class="o">=</span> <span class="n">ncdegree</span><span class="p">(</span><span class="n">equality</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">eq_order</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;An equality constraint has degree </span><span class="si">%d</span><span class="s2">. &quot;</span>
                                    <span class="s2">&quot;Choose a higher level of relaxation.&quot;</span>
                                    <span class="o">%</span> <span class="n">eq_order</span><span class="p">)</span>
                <span class="n">localization_order</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">-</span> <span class="n">eq_order</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">find_variable_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="n">equality</span><span class="p">)</span>
                <span class="n">localizing_monomials</span> <span class="o">=</span> \
                    <span class="n">pick_monomials_up_to_degree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">monomial_sets</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                                                <span class="n">localization_order</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">localizing_monomials</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">localizing_monomials</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">]</span>
                <span class="n">localizing_monomials</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">localizing_monomials</span><span class="p">)</span>
                <span class="n">monomial_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">localizing_monomials</span><span class="p">)</span>
                <span class="n">n_rows</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">localizing_monomials</span><span class="p">)</span> <span class="o">*</span> \
                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">localizing_monomials</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">momentequalities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">momentequalities</span><span class="p">:</span>
                <span class="n">le</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">monomial_sets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">])</span>
                <span class="n">n_rows</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">n_rows</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parallel</span><span class="p">:</span>
            <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">equality</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">flatten</span><span class="p">([</span><span class="n">equalities</span><span class="p">,</span> <span class="n">momentequalities</span><span class="p">])):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">moment_of_entry</span><span class="p">,</span> <span class="n">monomials</span><span class="o">=</span><span class="n">monomial_sets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                           <span class="n">ineq</span><span class="o">=</span><span class="n">equality</span><span class="p">,</span> <span class="n">substitutions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">substitutions</span><span class="p">)</span>
            <span class="n">lm</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomial_sets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parallel</span> <span class="ow">and</span> <span class="n">lm</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">chunksize</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lm</span><span class="o">*</span><span class="n">lm</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span>
                                    <span class="n">cpu_count</span><span class="p">()),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">iter_</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">([</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lm</span><span class="p">)</span>
                                        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">lm</span><span class="p">)),</span>
                                 <span class="n">chunksize</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iter_</span> <span class="o">=</span> <span class="n">imap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">([</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lm</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">lm</span><span class="p">)))</span>
            <span class="c1"># Process M_y(gy)(u,w) entries</span>
            <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">polynomial</span> <span class="ow">in</span> <span class="n">iter_</span><span class="p">:</span>
                <span class="c1"># Calculate the moments of polynomial entries</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__parse_expression</span><span class="p">(</span><span class="n">equality</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">n_rows</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">n_rows</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_facvar</span><span class="p">(</span><span class="n">polynomial</span><span class="p">)</span>
                <span class="n">n_rows</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\r\x1b</span><span class="s2">[KProcessing </span><span class="si">%d</span><span class="s2">/</span><span class="si">%d</span><span class="s2"> equalities...&quot;</span> <span class="o">%</span>
                                     <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">le</span><span class="p">))</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parallel</span><span class="p">:</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">A</span>

    <span class="k">def</span> <span class="nf">__remove_equalities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">equalities</span><span class="p">,</span> <span class="n">momentequalities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attempt to remove equalities by solving the linear equations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__process_equalities</span><span class="p">(</span><span class="n">equalities</span><span class="p">,</span> <span class="n">momentequalities</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: equality constraints are linearly dependent! &quot;</span>
                  <span class="s2">&quot;Results might be incorrect.&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_facvar</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;QR decomposition...&quot;</span><span class="p">)</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;complete&#39;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">R</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span> <span class="p">:]),</span> <span class="o">-</span><span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_new_basis</span> <span class="o">=</span> <span class="n">lil_matrix</span><span class="p">(</span><span class="n">Q</span><span class="p">[:,</span> <span class="n">n</span><span class="p">:])</span>
        <span class="c1"># Transforming the objective function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_obj_facvar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_facvar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_constant_term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant_term</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_facvar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_basis</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constant_term</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="c1"># Transforming the moment matrix and localizing matrices</span>
        <span class="n">new_F</span> <span class="o">=</span> <span class="n">lil_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_basis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">new_F</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">new_F</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                                <span class="mi">1</span><span class="p">))</span>
        <span class="n">new_F</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span>\
            <span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new_basis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_original_F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="n">new_F</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_basis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of variables after solving the linear equations: </span><span class="si">%d</span><span class="s2">&quot;</span>
                  <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__duplicate_momentmatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original_n_vars</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">,</span> <span class="n">block_index</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_vars</span><span class="p">)</span>
        <span class="n">row_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block_size</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">block_index</span><span class="p">]:</span>
            <span class="n">row_offset</span> <span class="o">+=</span> <span class="n">block_size</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="o">**</span><span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">row_offset</span> <span class="o">+</span> <span class="n">row</span><span class="p">,</span> <span class="n">n_vars</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n_vars</span> <span class="o">+</span> <span class="n">original_n_vars</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>\
                <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="p">:</span><span class="n">original_n_vars</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">n_vars</span> <span class="o">+</span> <span class="n">original_n_vars</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">block_index</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__add_new_momentmatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">,</span> <span class="n">block_index</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_vars</span><span class="p">)</span>
        <span class="n">row_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block_size</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">block_index</span><span class="p">]:</span>
            <span class="n">row_offset</span> <span class="o">+=</span> <span class="n">block_size</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
                <span class="n">n_vars</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">row_offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">n_vars</span><span class="p">,</span> <span class="n">block_index</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__impose_ppt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_index</span><span class="p">):</span>
        <span class="n">row_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block_size</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">block_index</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">row_offset</span> <span class="o">+=</span> <span class="n">block_size</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">lenA</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">monomial_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">lenB</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">monomial_sets</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">lenA</span><span class="o">*</span><span class="n">lenB</span>
        <span class="k">for</span> <span class="n">rowA</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lenA</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">columnA</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rowA</span><span class="p">,</span> <span class="n">lenA</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">rowB</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lenB</span><span class="p">):</span>
                    <span class="n">start_columnB</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">rowA</span> <span class="o">==</span> <span class="n">columnA</span><span class="p">:</span>
                        <span class="n">start_columnB</span> <span class="o">=</span> <span class="n">rowB</span>
                    <span class="k">for</span> <span class="n">columnB</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_columnB</span><span class="p">,</span> <span class="n">rowB</span><span class="p">):</span>
                        <span class="n">orig_row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">row_offset</span> <span class="o">+</span> <span class="n">rowA</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="n">lenB</span> <span class="o">+</span> <span class="n">rowB</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span>
                                          <span class="n">columnA</span> <span class="o">*</span> <span class="n">lenB</span> <span class="o">+</span> <span class="n">columnB</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">row_offset</span> <span class="o">+</span> <span class="n">rowA</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="n">lenB</span> <span class="o">+</span> <span class="n">rowB</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span>
                               <span class="n">columnA</span> <span class="o">*</span> <span class="n">lenB</span> <span class="o">+</span> <span class="n">columnB</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">row_offset</span> <span class="o">+</span> <span class="n">rowA</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="n">lenB</span> <span class="o">+</span> <span class="n">columnB</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span>
                                   <span class="n">columnA</span> <span class="o">*</span> <span class="n">lenB</span> <span class="o">+</span> <span class="n">rowB</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">row_offset</span> <span class="o">+</span> <span class="n">rowA</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="n">lenB</span> <span class="o">+</span> <span class="n">columnB</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span>
                               <span class="n">columnA</span> <span class="o">*</span> <span class="n">lenB</span> <span class="o">+</span> <span class="n">rowB</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig_row</span>

    <span class="k">def</span> <span class="nf">__add_extra_momentmatrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extramomentmatrices</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">,</span>
                                   <span class="n">block_index</span><span class="p">):</span>
        <span class="n">original_n_vars</span> <span class="o">=</span> <span class="n">n_vars</span>
        <span class="k">if</span> <span class="n">extramomentmatrices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">parameters</span> <span class="ow">in</span> <span class="n">extramomentmatrices</span><span class="p">:</span>
                <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">ppt</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">parameter</span> <span class="o">==</span> <span class="s2">&quot;copy&quot;</span><span class="p">:</span>
                        <span class="n">copy</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">parameter</span> <span class="o">==</span> <span class="s2">&quot;ppt&quot;</span><span class="p">:</span>
                        <span class="n">ppt</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                    <span class="n">n_vars</span><span class="p">,</span> <span class="n">block_index</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">__duplicate_momentmatrix</span><span class="p">(</span><span class="n">original_n_vars</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">,</span>
                                                      <span class="n">block_index</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">n_vars</span><span class="p">,</span> <span class="n">block_index</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">__add_new_momentmatrix</span><span class="p">(</span><span class="n">n_vars</span><span class="p">,</span> <span class="n">block_index</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ppt</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__impose_ppt</span><span class="p">(</span><span class="n">block_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n_vars</span><span class="p">,</span> <span class="n">block_index</span>

    <span class="k">def</span> <span class="nf">__parse_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">row_offset</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">sexprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">sexpr</span> <span class="k">for</span> <span class="n">sexpr</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sexpr</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">sexpr</span> <span class="ow">in</span> <span class="n">sexprs</span><span class="p">:</span>
                <span class="n">startindex</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">asterix_position</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">sexpr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">sexpr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">):</span>
                    <span class="n">asterix_position</span> <span class="o">=</span> <span class="n">sexpr</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">asterix_position</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">startindex</span> <span class="o">=</span> <span class="n">asterix_position</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">startindex</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">sexpr</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ind</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">sexpr</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">mm_ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sexpr</span><span class="p">[</span><span class="n">startindex</span><span class="p">:</span><span class="n">ind</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">asterix_position</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sexpr</span><span class="p">[:</span><span class="n">asterix_position</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">sexpr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">):</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="n">base_row_offset</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">bs</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">bs</span> <span class="ow">in</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="p">[:</span><span class="n">mm_ind</span><span class="p">]])</span>
                    <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="p">[</span><span class="n">mm_ind</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">row_offset</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">row_offset</span><span class="p">]</span> <span class="o">+=</span> \
                            <span class="n">value</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">base_row_offset</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">width</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">line</span> <span class="o">+=</span> <span class="n">value</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">base_row_offset</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">width</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span>
                                             <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sexpr</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">row_offset</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">row_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>

    <span class="c1">########################################################################</span>
    <span class="c1"># ROUTINES RELATED TO INITIALIZING DATA STRUCTURES                     #</span>
    <span class="c1">########################################################################</span>

    <span class="k">def</span> <span class="nf">_calculate_block_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inequalities</span><span class="p">,</span> <span class="n">equalities</span><span class="p">,</span>
                                   <span class="n">momentinequalities</span><span class="p">,</span> <span class="n">momentequalities</span><span class="p">,</span>
                                   <span class="n">extramomentmatrix</span><span class="p">,</span> <span class="n">removeequalities</span><span class="p">,</span>
                                   <span class="n">block_struct</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the block_struct array for the output file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">block_struct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating block structure...&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">monomials</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomial_sets</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomials</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">monomials</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">monomials</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">monomials</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">extramomentmatrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">extramomentmatrix</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">monomials</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomial_sets</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomials</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> \
                                <span class="nb">isinstance</span><span class="p">(</span><span class="n">monomials</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">monomials</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">monomials</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span> <span class="o">=</span> <span class="n">block_struct</span>
        <span class="n">degree_warning</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">inequalities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_inequalities</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inequalities</span><span class="p">)</span>
            <span class="n">n_tmp_inequalities</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inequalities</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_inequalities</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">n_tmp_inequalities</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">([</span><span class="n">inequalities</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">momentinequalities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_inequalities</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">momentinequalities</span><span class="p">)</span>
            <span class="n">constraints</span> <span class="o">+=</span> <span class="n">momentinequalities</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">removeequalities</span><span class="p">:</span>
            <span class="n">constraints</span> <span class="o">+=</span> <span class="n">flatten</span><span class="p">([</span><span class="n">equalities</span><span class="p">])</span>
        <span class="n">monomial_sets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">constraints</span><span class="p">):</span>
            <span class="c1"># Find the order of the localizing matrix</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n_tmp_inequalities</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_inequalities</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">ineq_order</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">constraint</span><span class="o">.</span><span class="n">is_Relational</span><span class="p">:</span>
                        <span class="n">constraint</span> <span class="o">=</span> <span class="n">convert_relational</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>
                    <span class="n">ineq_order</span> <span class="o">=</span> <span class="n">ncdegree</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">constraint</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">complex_matrix</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">ineq_order</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">:</span>
                    <span class="n">degree_warning</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">localization_order</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">-</span> <span class="n">ineq_order</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">localization_order</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">localizing_monomial_sets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">localizing_monomial_sets</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">localizing_monomials</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">localizing_monomial_sets</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">find_variable_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="n">constraint</span><span class="p">)</span>
                    <span class="n">localizing_monomials</span> <span class="o">=</span> \
                        <span class="n">pick_monomials_up_to_degree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">monomial_sets</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                                                    <span class="n">localization_order</span><span class="p">)</span>
                <span class="n">ln</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">localizing_monomials</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ln</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">localizing_monomials</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">localizing_monomials</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">]</span>
                <span class="n">ln</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">localizing_monomials</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">localizing_monomials</span><span class="p">)</span>
            <span class="n">monomial_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">localizing_monomials</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_inequalities</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">monomial_sets</span> <span class="o">+=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ln</span><span class="o">*</span><span class="p">(</span><span class="n">ln</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">monomial_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">localizing_monomials</span><span class="p">)</span>
                <span class="n">monomial_sets</span> <span class="o">+=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ln</span><span class="o">*</span><span class="p">(</span><span class="n">ln</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ln</span><span class="o">*</span><span class="p">(</span><span class="n">ln</span><span class="o">+</span><span class="mi">1</span><span class="p">))]</span>

        <span class="k">if</span> <span class="n">degree_warning</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A constraint has degree </span><span class="si">%d</span><span class="s2">. Either choose a higher level &quot;</span>
                  <span class="s2">&quot;relaxation or ensure that a mixed-order relaxation has the&quot;</span>
                  <span class="s2">&quot; necessary monomials&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ineq_order</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">momentequalities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">moment_eq</span> <span class="ow">in</span> <span class="n">momentequalities</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_moment_equalities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">moment_eq</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">removeequalities</span><span class="p">:</span>
                    <span class="n">monomial_sets</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">],</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">]]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">localizing_monomial_sets</span> <span class="o">=</span> <span class="n">monomial_sets</span>

    <span class="k">def</span> <span class="nf">__generate_monomial_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extramonomials</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">extramonomials</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">extramonomials</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot build relaxation at level -1 without </span><span class="se">\</span>
<span class="s2">                                monomials specified.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extramonomials</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">monomial_sets</span> <span class="o">=</span> <span class="n">extramonomials</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">monomial_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">extramonomials</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">variables</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                <span class="n">extramonomials_</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">extramonomials</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">extramonomials_</span> <span class="o">=</span> <span class="n">extramonomials</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">monomial_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">get_all_monomials</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">extramonomials_</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">substitutions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">))</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">extramonomials</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">extramonomials</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> \
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">extramonomials</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">monomial_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">get_all_monomials</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="n">extramonomials</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">substitutions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">monomial_sets</span> <span class="o">+=</span> <span class="n">extramonomials</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">monomial_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">get_all_monomials</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="n">extramonomials</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">substitutions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_estimate_n_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">monomials</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomial_sets</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomials</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">monomials</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">n_monomials</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomials</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_monomials</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomials</span><span class="p">)</span>

            <span class="c1"># The minus one compensates for the constant term in the</span>
            <span class="c1"># top left corner of the moment matrix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_monomials</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_monomials</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__add_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">new_n_vars</span><span class="p">,</span> <span class="n">block_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">block_index</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
                <span class="n">new_n_vars</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">monomial_index</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_n_vars</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">new_n_vars</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">new_n_vars</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">new_n_vars</span><span class="p">,</span> <span class="n">block_index</span>

    <span class="k">def</span> <span class="nf">__wipe_F_from_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">row_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint_starting_block</span><span class="p">):</span>
            <span class="n">row_offset</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="p">[</span><span class="n">block</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row_offset</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">rows</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">rows</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">########################################################################</span>
    <span class="c1"># PUBLIC ROUTINES EXPOSED TO THE USER                                  #</span>
    <span class="c1">########################################################################</span>

<div class="viewcode-block" id="SdpRelaxation.process_constraints"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.sdp_relaxation.SdpRelaxation.process_constraints">[docs]</a>    <span class="k">def</span> <span class="nf">process_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inequalities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">equalities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">momentinequalities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">momentequalities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">block_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">removeequalities</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process the constraints and generate localizing matrices. Useful</span>
<span class="sd">        only if the moment matrix already exists. Call it if you want to</span>
<span class="sd">        replace your constraints. The number of the respective types of</span>
<span class="sd">        constraints and the maximum degree of each constraint must remain the</span>
<span class="sd">        same.</span>

<span class="sd">        :param inequalities: Optional parameter to list inequality constraints.</span>
<span class="sd">        :type inequalities: list of :class:`sympy.core.exp.Expr`.</span>
<span class="sd">        :param equalities: Optional parameter to list equality constraints.</span>
<span class="sd">        :type equalities: list of :class:`sympy.core.exp.Expr`.</span>
<span class="sd">        :param momentinequalities: Optional parameter of inequalities defined</span>
<span class="sd">                                   on moments.</span>
<span class="sd">        :type momentinequalities: list of :class:`sympy.core.exp.Expr`.</span>
<span class="sd">        :param momentequalities: Optional parameter of equalities defined</span>
<span class="sd">                                 on moments.</span>
<span class="sd">        :type momentequalities: list of :class:`sympy.core.exp.Expr`.</span>
<span class="sd">        :param removeequalities: Optional parameter to attempt removing the</span>
<span class="sd">                                 equalities by solving the linear equations.</span>

<span class="sd">        :param removeequalities: Optional parameter to attempt removing the</span>
<span class="sd">                                 equalities by solving the linear equations.</span>
<span class="sd">        :type removeequalities: bool.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;unsolved&quot;</span>
        <span class="k">if</span> <span class="n">block_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_F</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_F</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">obj_facvar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_obj_facvar</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">constant_term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_original_constant_term</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_facvar</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_new_basis</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">block_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraint_starting_block</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__wipe_F_from_constraints</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">([</span><span class="n">inequalities</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constraint_to_block_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constraint_to_block_index</span><span class="p">[</span><span class="n">constraint</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_index</span><span class="p">,</span> <span class="p">)</span>
            <span class="n">block_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">momentinequalities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">mineq</span> <span class="ow">in</span> <span class="n">momentinequalities</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mineq</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_constraint_to_block_index</span><span class="p">[</span><span class="n">mineq</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_index</span><span class="p">,</span> <span class="p">)</span>
                <span class="n">block_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">removeequalities</span> <span class="ow">or</span> <span class="n">equalities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># Equalities are converted to pairs of inequalities</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">equality</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">equalities</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">equality</span><span class="o">.</span><span class="n">is_Relational</span><span class="p">:</span>
                    <span class="n">equality</span> <span class="o">=</span> <span class="n">convert_relational</span><span class="p">(</span><span class="n">equality</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">equality</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">equality</span><span class="p">)</span>
                <span class="n">ln</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">localizing_monomial_sets</span><span class="p">[</span><span class="n">block_index</span><span class="o">-</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">constraint_starting_block</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_constraint_to_block_index</span><span class="p">[</span><span class="n">equality</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_index</span><span class="p">,</span>
                                                             <span class="n">block_index</span><span class="o">+</span><span class="n">ln</span><span class="o">*</span><span class="p">(</span><span class="n">ln</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">block_index</span> <span class="o">+=</span> <span class="n">ln</span><span class="o">*</span><span class="p">(</span><span class="n">ln</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">momentequalities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">removeequalities</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">meq</span> <span class="ow">in</span> <span class="n">momentequalities</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span> <span class="o">+=</span> <span class="p">[</span><span class="n">meq</span><span class="p">,</span> <span class="n">flip_sign</span><span class="p">(</span><span class="n">meq</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_constraint_to_block_index</span><span class="p">[</span><span class="n">meq</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_index</span><span class="p">,</span>
                                                        <span class="n">block_index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">block_index</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">block_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraint_starting_block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__process_inequalities</span><span class="p">(</span><span class="n">block_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">removeequalities</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__remove_equalities</span><span class="p">(</span><span class="n">equalities</span><span class="p">,</span> <span class="n">momentequalities</span><span class="p">)</span></div>

<div class="viewcode-block" id="SdpRelaxation.set_objective"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.sdp_relaxation.SdpRelaxation.set_objective">[docs]</a>    <span class="k">def</span> <span class="nf">set_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objective</span><span class="p">,</span> <span class="n">extraobjexpr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set or change the objective function of the polynomial optimization</span>
<span class="sd">        problem.</span>

<span class="sd">        :param objective: Describes the objective function.</span>
<span class="sd">        :type objective: :class:`sympy.core.expr.Expr`</span>
<span class="sd">        :param extraobjexpr: Optional parameter of a string expression of a</span>
<span class="sd">                             linear combination of moment matrix elements to be</span>
<span class="sd">                             included in the objective function</span>
<span class="sd">        :type extraobjexpr: str.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">objective</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">facvar</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_facvar</span><span class="p">(</span><span class="n">simplify_polynomial</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">substitutions</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obj_facvar</span> <span class="o">=</span> <span class="n">facvar</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constant_term</span> <span class="o">=</span> <span class="n">facvar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">facvar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: The objective function has a non-zero </span><span class="si">%s</span><span class="s2"> &quot;</span>
                      <span class="s2">&quot;constant term. It is not included in the SDP objective.&quot;</span>
                      <span class="o">%</span> <span class="n">facvar</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obj_facvar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_facvar</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">extraobjexpr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sub_expr</span> <span class="ow">in</span> <span class="n">extraobjexpr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">):</span>
                <span class="n">startindex</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">asterix_position</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">sub_expr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">sub_expr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">):</span>
                    <span class="n">asterix_position</span> <span class="o">=</span> <span class="n">sub_expr</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">asterix_position</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">startindex</span> <span class="o">=</span> <span class="n">asterix_position</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">startindex</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">sub_expr</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ind</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">sub_expr</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">mm_ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">[</span><span class="n">startindex</span><span class="p">:</span><span class="n">ind</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">asterix_position</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">[:</span><span class="n">asterix_position</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">sub_expr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">):</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="n">base_row_offset</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">bs</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">bs</span> <span class="ow">in</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="p">[:</span><span class="n">mm_ind</span><span class="p">]])</span>
                    <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="p">[</span><span class="n">mm_ind</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">base_row_offset</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">width</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">rows</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">obj_facvar</span><span class="p">[</span><span class="n">column</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="n">value</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">base_row_offset</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">width</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">column</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Obtained the value for a polynomial in a solved relaxation.</span>

<span class="sd">        :param index: The polynomial.</span>
<span class="sd">        :type index: `sympy.core.exp.Expr`</span>

<span class="sd">        :returns: The value of the polynomial extracted from the solved SDP.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not a monomial or polynomial!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s2">&quot;unsolved&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;SDP relaxation is not solved yet!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">get_xmat_value</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="SdpRelaxation.get_sos_decomposition"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.sdp_relaxation.SdpRelaxation.get_sos_decomposition">[docs]</a>    <span class="k">def</span> <span class="nf">get_sos_decomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a solution of the dual problem, it returns the SOS</span>
<span class="sd">        decomposition.</span>

<span class="sd">        :param threshold: Optional parameter for specifying the threshold value</span>
<span class="sd">                          below which the eigenvalues and entries of the</span>
<span class="sd">                          eigenvectors are disregarded.</span>
<span class="sd">        :type threshold: float.</span>
<span class="sd">        :returns: The SOS decomposition of [sigma_0, sigma_1, ..., sigma_m]</span>
<span class="sd">        :rtype: list of :class:`sympy.core.exp.Expr`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_sos_decomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span></div>

<div class="viewcode-block" id="SdpRelaxation.extract_dual_value"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.sdp_relaxation.SdpRelaxation.extract_dual_value">[docs]</a>    <span class="k">def</span> <span class="nf">extract_dual_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monomial</span><span class="p">,</span> <span class="n">blocks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a solution of the dual problem and a monomial, it returns the</span>
<span class="sd">        inner product of the corresponding coefficient matrix and the dual</span>
<span class="sd">        solution. It can be restricted to certain blocks.</span>

<span class="sd">        :param monomial: The monomial for which the value is requested.</span>
<span class="sd">        :type monomial: :class:`sympy.core.exp.Expr`.</span>
<span class="sd">        :param monomial: The monomial for which the value is requested.</span>
<span class="sd">        :type monomial: :class:`sympy.core.exp.Expr`.</span>
<span class="sd">        :param blocks: Optional parameter to specify the blocks to be included.</span>
<span class="sd">        :type blocks: list of `int`.</span>
<span class="sd">        :returns: The value of the monomial in the solved relaxation.</span>
<span class="sd">        :rtype: float.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">extract_dual_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monomial</span><span class="p">,</span> <span class="n">blocks</span><span class="p">)</span></div>

<div class="viewcode-block" id="SdpRelaxation.find_solution_ranks"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.sdp_relaxation.SdpRelaxation.find_solution_ranks">[docs]</a>    <span class="k">def</span> <span class="nf">find_solution_ranks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">baselevel</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function to detect rank loop in the solution matrix.</span>

<span class="sd">        :param sdpRelaxation: The SDP relaxation.</span>
<span class="sd">        :type sdpRelaxation: :class:`ncpol2sdpa.SdpRelaxation`.</span>
<span class="sd">        :param x_mat: Optional parameter providing the primal solution of the</span>
<span class="sd">                      moment matrix. If not provided, the solution is extracted</span>
<span class="sd">                      from the sdpRelaxation object.</span>
<span class="sd">        :type x_mat: :class:`numpy.array`.</span>
<span class="sd">        :param base_level: Optional parameter for specifying the lower level</span>
<span class="sd">                           relaxation for which the rank loop should be tested</span>
<span class="sd">                           against.</span>
<span class="sd">        :type base_level: int.</span>
<span class="sd">        :returns: list of int -- the ranks of the solution matrix with in the</span>
<span class="sd">                  order of increasing degree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">find_solution_ranks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmat</span><span class="o">=</span><span class="n">xmat</span><span class="p">,</span> <span class="n">baselevel</span><span class="o">=</span><span class="n">baselevel</span><span class="p">)</span></div>

<div class="viewcode-block" id="SdpRelaxation.get_dual"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.sdp_relaxation.SdpRelaxation.get_dual">[docs]</a>    <span class="k">def</span> <span class="nf">get_dual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">ymat</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a solution of the dual problem and a constraint of any type,</span>
<span class="sd">        it returns the corresponding block in the dual solution. If it is an</span>
<span class="sd">        equality constraint that was converted to a pair of inequalities, it</span>
<span class="sd">        returns a two-tuple of the matching dual blocks.</span>

<span class="sd">        :param constraint: The constraint.</span>
<span class="sd">        :type index: `sympy.core.exp.Expr`</span>
<span class="sd">        :param y_mat: Optional parameter providing the dual solution of the</span>
<span class="sd">                      SDP. If not provided, the solution is extracted</span>
<span class="sd">                      from the sdpRelaxation object.</span>
<span class="sd">        :type y_mat: :class:`numpy.array`.</span>
<span class="sd">        :returns: The corresponding block in the dual solution.</span>
<span class="sd">        :rtype: :class:`numpy.array` or a tuple thereof.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not a monomial or polynomial!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s2">&quot;unsolved&quot;</span> <span class="ow">and</span> <span class="n">ymat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;SDP relaxation is not solved yet!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ymat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ymat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_mat</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraint_to_block_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Constraint is not in the dual!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ymat</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_mat</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ymat</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span></div>

<div class="viewcode-block" id="SdpRelaxation.write_to_file"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.sdp_relaxation.SdpRelaxation.write_to_file">[docs]</a>    <span class="k">def</span> <span class="nf">write_to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">filetype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the relaxation to a file.</span>

<span class="sd">        :param filename: The name of the file to write to. The type can be</span>
<span class="sd">                         autodetected from the extension: .dat-s for SDPA,</span>
<span class="sd">                         .task for mosek or .csv for human readable format.</span>
<span class="sd">        :type filename: str.</span>
<span class="sd">        :param filetype: Optional parameter to define the filetype. It can be</span>
<span class="sd">                         &quot;sdpa&quot; for SDPA , &quot;mosek&quot; for Mosek, or &quot;csv&quot; for</span>
<span class="sd">                         human readable format.</span>
<span class="sd">        :type filetype: str.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filetype</span> <span class="o">==</span> <span class="s2">&quot;sdpa&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.dat-s&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;SDPA files must have .dat-s extension!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filetype</span> <span class="o">==</span> <span class="s2">&quot;mosek&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.task&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Mosek files must have .task extension!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">filetype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.dat-s&quot;</span><span class="p">):</span>
            <span class="n">filetype</span> <span class="o">=</span> <span class="s2">&quot;sdpa&quot;</span>
        <span class="k">elif</span> <span class="n">filetype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.csv&quot;</span><span class="p">):</span>
            <span class="n">filetype</span> <span class="o">=</span> <span class="s2">&quot;csv&quot;</span>
        <span class="k">elif</span> <span class="n">filetype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.task&quot;</span><span class="p">):</span>
            <span class="n">filetype</span> <span class="o">=</span> <span class="s2">&quot;mosek&quot;</span>
        <span class="k">elif</span> <span class="n">filetype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot detect filetype from extension!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filetype</span> <span class="o">==</span> <span class="s2">&quot;sdpa&quot;</span><span class="p">:</span>
            <span class="n">write_to_sdpa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">filetype</span> <span class="o">==</span> <span class="s2">&quot;mosek&quot;</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="n">convert_to_mosek</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">writedata</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">filetype</span> <span class="o">==</span> <span class="s2">&quot;csv&quot;</span><span class="p">:</span>
            <span class="n">write_to_human_readable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown filetype&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SdpRelaxation.save_monomial_index"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.sdp_relaxation.SdpRelaxation.save_monomial_index">[docs]</a>    <span class="k">def</span> <span class="nf">save_monomial_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the monomial index to a file.</span>

<span class="sd">        :param filename: The name of the file to write to.</span>
<span class="sd">        :type filename: str.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">save_monomial_index</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomial_index</span><span class="p">)</span></div>

<div class="viewcode-block" id="SdpRelaxation.convert_to_cvxpy"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.sdp_relaxation.SdpRelaxation.convert_to_cvxpy">[docs]</a>    <span class="k">def</span> <span class="nf">convert_to_cvxpy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert an SDP relaxation to a CVXPY problem.</span>

<span class="sd">        :returns: :class:`cvxpy.Problem`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">convert_to_cvxpy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="SdpRelaxation.convert_to_picos"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.sdp_relaxation.SdpRelaxation.convert_to_picos">[docs]</a>    <span class="k">def</span> <span class="nf">convert_to_picos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">duplicate_moment_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the SDP relaxation to a PICOS problem such that the exported</span>
<span class="sd">        .dat-s file is extremely sparse, there is not penalty imposed in terms</span>
<span class="sd">        of SDP variables or number of constraints. This conversion can be used</span>
<span class="sd">        for imposing extra constraints on the moment matrix, such as partial</span>
<span class="sd">        transpose.</span>

<span class="sd">        :param duplicate_moment_matrix: Optional parameter to add an</span>
<span class="sd">                                        unconstrained moment matrix to the</span>
<span class="sd">                                        problem with the same structure as the</span>
<span class="sd">                                        moment matrix with the PSD constraint.</span>
<span class="sd">        :type duplicate_moment_matrix: bool.</span>

<span class="sd">        :returns: :class:`picos.Problem`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> \
            <span class="n">convert_to_picos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">duplicate_moment_matrix</span><span class="o">=</span><span class="n">duplicate_moment_matrix</span><span class="p">)</span></div>

<div class="viewcode-block" id="SdpRelaxation.convert_to_mosek"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.sdp_relaxation.SdpRelaxation.convert_to_mosek">[docs]</a>    <span class="k">def</span> <span class="nf">convert_to_mosek</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert an SDP relaxation to a MOSEK task.</span>

<span class="sd">        :returns: :class:`mosek.Task`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">convert_to_mosek</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="SdpRelaxation.get_relaxation"><a class="viewcode-back" href="../../ncpol2sdpa.html#ncpol2sdpa.sdp_relaxation.SdpRelaxation.get_relaxation">[docs]</a>    <span class="k">def</span> <span class="nf">get_relaxation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">objective</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inequalities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">equalities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">substitutions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">momentinequalities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">momentequalities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">momentsubstitutions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">removeequalities</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">extramonomials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">extramomentmatrices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extraobjexpr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">localizing_monomials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chordal_extension</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the SDP relaxation of a noncommutative polynomial optimization</span>
<span class="sd">        problem.</span>

<span class="sd">        :param level: The level of the relaxation. The value -1 will skip</span>
<span class="sd">                      automatic monomial generation and use only the monomials</span>
<span class="sd">                      supplied by the option `extramonomials`.</span>
<span class="sd">        :type level: int.</span>
<span class="sd">        :param obj: Optional parameter to describe the objective function.</span>
<span class="sd">        :type obj: :class:`sympy.core.exp.Expr`.</span>
<span class="sd">        :param inequalities: Optional parameter to list inequality constraints.</span>
<span class="sd">        :type inequalities: list of :class:`sympy.core.exp.Expr`.</span>
<span class="sd">        :param equalities: Optional parameter to list equality constraints.</span>
<span class="sd">        :type equalities: list of :class:`sympy.core.exp.Expr`.</span>
<span class="sd">        :param substitutions: Optional parameter containing monomials that can</span>
<span class="sd">                              be replaced (e.g., idempotent variables).</span>
<span class="sd">        :type substitutions: dict of :class:`sympy.core.exp.Expr`.</span>
<span class="sd">        :param momentinequalities: Optional parameter of inequalities defined</span>
<span class="sd">                                   on moments.</span>
<span class="sd">        :type momentinequalities: list of :class:`sympy.core.exp.Expr`.</span>
<span class="sd">        :param momentequalities: Optional parameter of equalities defined</span>
<span class="sd">                                 on moments.</span>
<span class="sd">        :type momentequalities: list of :class:`sympy.core.exp.Expr`.</span>
<span class="sd">        :param momentsubstitutions: Optional parameter containing moments that</span>
<span class="sd">                                    can be replaced.</span>
<span class="sd">        :type momentsubstitutions: dict of :class:`sympy.core.exp.Expr`.</span>
<span class="sd">        :param removeequalities: Optional parameter to attempt removing the</span>
<span class="sd">                                 equalities by solving the linear equations.</span>
<span class="sd">        :type removeequalities: bool.</span>
<span class="sd">        :param extramonomials: Optional paramter of monomials to be included,</span>
<span class="sd">                               on top of the requested level of relaxation.</span>
<span class="sd">        :type extramonomials: list of :class:`sympy.core.exp.Expr`.</span>
<span class="sd">        :param extramomentmatrices: Optional paramter of duplicating or adding</span>
<span class="sd">                               moment matrices.  A new moment matrix can be</span>
<span class="sd">                               unconstrained (&quot;&quot;), a copy  of the first one</span>
<span class="sd">                               (&quot;copy&quot;), and satisfying a partial positivity</span>
<span class="sd">                               constraint (&quot;ppt&quot;). Each new moment matrix is</span>
<span class="sd">                               requested as a list of string of these options.</span>
<span class="sd">                               For instance, adding a single new moment matrix</span>
<span class="sd">                               as a copy of the first would be</span>
<span class="sd">                               ``extramomentmatrices=[[&quot;copy&quot;]]``.</span>
<span class="sd">        :type extramomentmatrices: list of list of str.</span>
<span class="sd">        :param extraobjexpr: Optional parameter of a string expression of a</span>
<span class="sd">                             linear combination of moment matrix elements to be</span>
<span class="sd">                             included in the objective function.</span>
<span class="sd">        :type extraobjexpr: str.</span>
<span class="sd">        :param localizing_monomials: Optional parameter to specify sets of</span>
<span class="sd">                                     localizing monomials for each constraint.</span>
<span class="sd">                                     The internal order of constraints is</span>
<span class="sd">                                     inequalities first, followed by the</span>
<span class="sd">                                     equalities. If the parameter is specified,</span>
<span class="sd">                                     but for a certain constraint the automatic</span>
<span class="sd">                                     localization is requested, leave None in</span>
<span class="sd">                                     its place in this parameter.</span>
<span class="sd">        :type localizing_monomials: list of list of `sympy.core.exp.Expr`.</span>
<span class="sd">        :param chordal_extension: Optional parameter to request a sparse</span>
<span class="sd">                                  chordal extension.</span>
<span class="sd">        :type chordal_extension: bool.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Invalid level of relaxation&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span>
        <span class="k">if</span> <span class="n">substitutions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">substitutions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">substitutions</span> <span class="o">=</span> <span class="n">substitutions</span>
            <span class="k">for</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">substitutions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_pure_substitution_rule</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pure_substitution_rules</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="ow">or</span> <span class="n">iscomplex</span><span class="p">(</span><span class="n">rhs</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">complex_matrix</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">momentsubstitutions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">moment_substitutions</span> <span class="o">=</span> <span class="n">momentsubstitutions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># If we have a real-valued problem, the moment matrix is symmetric</span>
            <span class="c1"># and moment substitutions also apply to the conjugate monomials</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">complex_matrix</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">moment_substitutions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">adjoint_monomial</span> <span class="o">=</span> <span class="n">apply_substitutions</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(),</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">substitutions</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">moment_substitutions</span><span class="p">[</span><span class="n">adjoint_monomial</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">if</span> <span class="n">chordal_extension</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">find_variable_cliques</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="n">objective</span><span class="p">,</span>
                                                   <span class="n">inequalities</span><span class="p">,</span> <span class="n">equalities</span><span class="p">,</span>
                                                   <span class="n">momentinequalities</span><span class="p">,</span>
                                                   <span class="n">momentequalities</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__generate_monomial_sets</span><span class="p">(</span><span class="n">extramonomials</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">localizing_monomial_sets</span> <span class="o">=</span> <span class="n">localizing_monomials</span>

        <span class="c1"># Figure out basic structure of the SDP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_block_structure</span><span class="p">(</span><span class="n">inequalities</span><span class="p">,</span> <span class="n">equalities</span><span class="p">,</span>
                                        <span class="n">momentinequalities</span><span class="p">,</span> <span class="n">momentequalities</span><span class="p">,</span>
                                        <span class="n">extramomentmatrices</span><span class="p">,</span>
                                        <span class="n">removeequalities</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_n_vars</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">extramomentmatrices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">parameters</span> <span class="ow">in</span> <span class="n">extramomentmatrices</span><span class="p">:</span>
                <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">parameter</span> <span class="o">==</span> <span class="s2">&quot;copy&quot;</span><span class="p">:</span>
                        <span class="n">copy</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">complex_matrix</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="n">lil_matrix</span><span class="p">((</span><span class="nb">sum</span><span class="p">([</span><span class="n">bs</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">bs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_struct</span><span class="p">]),</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;Estimated number of SDP variables: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Generating moment matrix...&#39;</span><span class="p">)</span>
        <span class="c1"># Generate moment matrices</span>
        <span class="n">new_n_vars</span><span class="p">,</span> <span class="n">block_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add_parameters</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">new_n_vars</span><span class="p">,</span> <span class="n">block_index</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_all_moment_matrix_blocks</span><span class="p">(</span><span class="n">new_n_vars</span><span class="p">,</span> <span class="n">block_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extramomentmatrices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_n_vars</span><span class="p">,</span> <span class="n">block_index</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">__add_extra_momentmatrices</span><span class="p">(</span><span class="n">extramomentmatrices</span><span class="p">,</span>
                                                <span class="n">new_n_vars</span><span class="p">,</span> <span class="n">block_index</span><span class="p">)</span>
        <span class="c1"># The initial estimate for the size of F was overly generous.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">=</span> <span class="n">new_n_vars</span>
        <span class="c1"># We don&#39;t correct the size of F, because that would trigger</span>
        <span class="c1"># memory copies, and extra columns in lil_matrix are free anyway.</span>
        <span class="c1"># self.F = self.F[:, 0:self.n_vars + 1]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;Reduced number of SDP variables: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vars</span><span class="p">))</span>
        <span class="c1"># Objective function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_objective</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">extraobjexpr</span><span class="p">)</span>
        <span class="c1"># Process constraints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraint_starting_block</span> <span class="o">=</span> <span class="n">block_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_constraints</span><span class="p">(</span><span class="n">inequalities</span><span class="p">,</span> <span class="n">equalities</span><span class="p">,</span> <span class="n">momentinequalities</span><span class="p">,</span>
                                 <span class="n">momentequalities</span><span class="p">,</span> <span class="n">block_index</span><span class="p">,</span>
                                 <span class="n">removeequalities</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Emanuel-Cristian Boghiu, Alejandro Pozas-Kerstjens.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>